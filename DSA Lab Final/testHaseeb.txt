{
	"Matrix Class": {
		"scope": "cpp",
		"prefix": "matrixclass",
		"body": [
			"class Matrix {",
			"    int rows;",
			"    int cols;",
			"    int** matrix;",
			"public:",
			"    Matrix(int r, int c) : rows(r), cols(c) {",
			"        matrix = new int*[rows];",
			"        for (int i = 0; i < rows; i++) {",
			"            matrix[i] = new int[cols];",
			"        }",
			"        for (int i = 0; i < rows; ++i) {",
			"            for (int j = 0; j < cols; ++j) {",
			"                matrix[i][j] = 0;",
			"            }",
			"        }",
			"    }",
			"",
			"    void matrix_input() {",
			"        cout << \"input matrix element:\" << endl;",
			"        for (int i = 0; i < rows; ++i) {",
			"            for (int j = 0; j < cols; ++j) {",
			"                cout << \"Element at \" << i << \",\" << j << \": \";",
			"                cin >> matrix[i][j];",
			"            }",
			"        }",
			"    }",
			"",
			"    void resize(int newr, int newc) {",
			"        int** newmatrix = new int*[newr];",
			"        for (int i = 0; i < newr; ++i) {",
			"            newmatrix[i] = new int[newc];",
			"        }",
			"        for (int i = 0; i < newr; ++i) {",
			"            for (int j = 0; j < newc; ++j) {",
			"                if (i < rows && j < cols) {",
			"                    newmatrix[i][j] = matrix[i][j];",
			"                } else {",
			"                    newmatrix[i][j] = 0;",
			"                }",
			"            }",
			"        }",
			"        for (int i = 0; i < rows; ++i) {",
			"            delete[] matrix[i];",
			"        }",
			"        delete[] matrix;",
			"        matrix = newmatrix;",
			"        rows = newr;",
			"        cols = newc;",
			"    }",
			"",
			"    void transposematrix() {",
			"        int** transpose = new int*[cols];",
			"        for (int i = 0; i < cols; i++) {",
			"            transpose[i] = new int[rows];",
			"        }",
			"        for (int i = 0; i < cols; i++) {",
			"            for (int j = 0; j < rows; j++) {",
			"                transpose[i][j] = matrix[j][i];",
			"            }",
			"        }",
			"        swap(rows, cols);",
			"        matrix = transpose;",
			"    }",
			"",
			"    void print() {",
			"        for (int i = 0; i < rows; ++i) {",
			"            for (int j = 0; j < cols; ++j) {",
			"                cout << matrix[i][j] << \" \";",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"",
			"    void add_2_matrix() const {",
			"        int index = 0;",
			"        for (int i = 0; i < rows; ++i) {",
			"            for (int j = 0; j < cols; ++j) {",
			"                if (index % 2 == 1) {",
			"                    cout << matrix[i][j] + 2 << \" \";",
			"                } else {",
			"                    cout << matrix[i][j] << \" \";",
			"                }",
			"                ++index;",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"};"
		],
		"description": "C++ Matrix Class with matrix input, resize, transpose, print, and add_2_matrix methods."
	},
	"Jagged Array Class": {
		"scope": "cpp",
		"prefix": "jaggedarray",
		"body": [
			"class jaggedarray {",
			"    int** array;",
			"    int rows;",
			"    int* cols;",
			"public:",
			"    jaggedarray(int r) : rows(r) {",
			"        cols = new int[r];",
			"        array = new int*[r];",
			"        for (int i = 0; i < r; i++) {",
			"            cout << \"Enter the number of columns for row \" << i + 1 << \": \";",
			"            cin >> cols[i];",
			"            array[i] = new int[cols[i]];",
			"        }",
			"    }",
			"",
			"    void jaggedarray_input() {",
			"        cout << \"input matrix\" << endl;",
			"        for (int i = 0; i < rows; ++i) {",
			"            for (int j = 0; j < cols[i]; ++j) {",
			"                cout << \"Element at \" << i << \",\" << j << \": \";",
			"                cin >> array[i][j];",
			"            }",
			"        }",
			"    }",
			"",
			"    void jaggedarray_resizerow(int index, int newsize) {",
			"        if (index < rows) {",
			"            int* temp = array[index];",
			"            array[index] = new int[newsize];",
			"            for (int j = 0; j < newsize; ++j) {",
			"                if (j < cols[index]) {",
			"                    array[index][j] = temp[j];",
			"                } else {",
			"                    array[index][j] = 0;",
			"                }",
			"            }",
			"            delete[] temp;",
			"            cols[index] = newsize;",
			"        }",
			"    }",
			"",
			"    void print() {",
			"        for (int i = 0; i < rows; ++i) {",
			"            for (int j = 0; j < cols[i]; ++j) {",
			"                cout << array[i][j] << \" \";",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"};"
		],
		"description": "C++ Jagged Array Class with Constructor, Input, Resize Row, and Print Functions"
	},
	"Matrix Multiplication": {
		"scope": "cpp",
		"prefix": "matricemultiply",
		"body": [
			"void matricemultiply(int row1, int col1, int row2, int col2, int** mat1, int** mat2, int** result) {",
			"    if (col1 != row2) {",
			"        cout << \"Error.\" << endl;",
			"        return;",
			"    }",
			"    for (int i = 0; i < row1; ++i) {",
			"        for (int j = 0; j < col2; ++j) {",
			"            result[i][j] = 0;",
			"        }",
			"    }",
			"    for (int i = 0; i < row1; ++i) {",
			"        for (int j = 0; j < col2; ++j) {",
			"            for (int k = 0; k < col1; ++k) {",
			"                result[i][j] += mat1[i][k] * mat2[k][j];",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "C++ Matrix Multiplication Function"
	},
	"Node Class": {
		"scope": "cpp",
		"prefix": "nodeclass",
		"body": [
			"class Node {",
			"    int data;",
			"    Node* next;",
			"",
			"    public:",
			"        Node(int value): data(value), next(nullptr) {}",
			"        friend class Linkedlist;",
			"};"
		],
		"description": "A basic Node class for linked lists"
	},
	"Linkedlist Class": {
		"scope": "cpp",
		"prefix": "linkedlistclass",
		"body": [
			"class Linkedlist {",
			"    Node *head;",
			"",
			"public:",
			"    Linkedlist(): head(nullptr) {}",
			"",
			"    void insert_at_end(int val) {",
			"        Node *n = new Node(val);",
			"        if (head == nullptr) {",
			"            head = n;",
			"            return;",
			"        }",
			"        Node *currentptr = head;",
			"        while (currentptr->next != nullptr) {",
			"            currentptr = currentptr->next;",
			"        }",
			"        currentptr->next = n;",
			"    }",
			"",
			"    void insert_at_start(int val) {",
			"        Node *n = new Node(val);",
			"        if (head == nullptr) {",
			"            head = n;",
			"            return;",
			"        }",
			"        n->next = head;",
			"        head = n;",
			"    }",
			"",
			"    void delete_at_start() {",
			"        if (head == nullptr) {",
			"            cout << \"List is empty\" << endl;",
			"            return;",
			"        }",
			"        Node *temp = head;",
			"        head = head->next;",
			"        delete temp;",
			"    }",
			"",
			"    void delete_at_end() {",
			"        if (head == nullptr) {",
			"            cout << \"List is empty\" << endl;",
			"            return;",
			"        }",
			"        if (head->next == nullptr) {",
			"            delete head;",
			"            head = nullptr;",
			"            return;",
			"        }",
			"        Node *currentptr = head;",
			"        while (currentptr->next->next != nullptr) {",
			"            currentptr = currentptr->next;",
			"        }",
			"        delete currentptr->next;",
			"        currentptr->next = nullptr;",
			"    }",
			"",
			"    void delete_at_anyposition(int pos) {",
			"        if (head == nullptr) {",
			"            cout << \"List is empty\" << endl;",
			"            return;",
			"        }",
			"        if (pos == 0) {",
			"            delete_at_start();",
			"            return;",
			"        }",
			"        Node *currentptr = head;",
			"        Node *prev = nullptr;",
			"        for (int i = 0; currentptr != nullptr && i < pos; i++) {",
			"            prev = currentptr;",
			"            currentptr = currentptr->next;",
			"        }",
			"        if (currentptr == nullptr) {",
			"            cout << \"Position does not exist.\" << endl;",
			"            return;",
			"        }",
			"        prev->next = currentptr->next;",
			"        delete currentptr;",
			"    }",
			"",
			"    void insert_after_position(int pos, int val) {",
			"        Node *n = new Node(val);",
			"        if (head == nullptr) {",
			"            cout << \"List is empty. Inserting at start.\" << endl;",
			"            head = n;",
			"            return;",
			"        }",
			"        Node *currentptr = head;",
			"        for (int i = 0; currentptr != nullptr && i < pos; i++) {",
			"            currentptr = currentptr->next;",
			"        }",
			"        if (currentptr == nullptr) {",
			"            cout << \"Position does not exist.\" << endl;",
			"            delete n;",
			"            return;",
			"        }",
			"        n->next = currentptr->next;",
			"        currentptr->next = n;",
			"    }",
			"",
			"    void reverse(int s, int e) {",
			"        Node *start = head;",
			"        Node *end = head;",
			"        for (int i = 0; i < s; i++) {",
			"            start = start->next;",
			"        }",
			"        for (int i = 0; i < e; i++) {",
			"            end = end->next;",
			"        }",
			"        for (int i = 0; i < e - s; i++) {",
			"            Node *currentptr = start;",
			"            for (int j = 0; j < e - s; j++) {",
			"                if (currentptr->data < currentptr->next->data) {",
			"                    int temp = currentptr->next->data;",
			"                    currentptr->next->data = currentptr->data;",
			"                    currentptr->data = temp;",
			"                    currentptr = currentptr->next;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    void display() {",
			"        Node *currentptr = head;",
			"        while (currentptr) {",
			"            cout << currentptr->data << \"->\";",
			"            currentptr = currentptr->next;",
			"        }",
			"        cout << \"NULL\";",
			"    }",
			"",
			"    void remove_duplicate() {",
			"        if (head == nullptr) {",
			"            return;",
			"        }",
			"        Node *currentptr = head;",
			"        while (currentptr->next != nullptr) {",
			"            if (currentptr->data == currentptr->next->data) {",
			"                Node *temp = currentptr->next;",
			"                currentptr->next = currentptr->next->next;",
			"                delete temp;",
			"            } else {",
			"                currentptr = currentptr->next;",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "A basic LinkedList class with operations to insert, delete, and display nodes."
	},
	"Circular Linked List with Insert, Delete, Search": {
		"scope": "cpp",
		"prefix": "circularlinkedlist",
		"body": [
			"class Node {",
			"public:",
			"    int data;",
			"    Node *next;",
			"",
			"    Node() {",
			"        data = 0;",
			"        next = NULL;",
			"    }",
			"",
			"    Node(int val) {",
			"        data = val;",
			"        next = NULL;",
			"    }",
			"};",
			"",
			"class Circular {",
			"public:",
			"    Node *head;",
			"    Node *tail;",
			"",
			"    Circular() {",
			"        head = NULL;",
			"        tail = NULL;",
			"    }",
			"",
			"    void insertAtEnd(int val) {",
			"        Node *n = new Node(val);",
			"        if (head == NULL) {",
			"            head = n;",
			"            tail = n;",
			"            tail->next = head;",
			"        } else {",
			"            tail->next = n;",
			"            tail = tail->next;",
			"            tail->next = head;",
			"        }",
			"    }",
			"",
			"    void insertAtFront(int val) {",
			"        Node *n = new Node(val);",
			"        tail->next = n;",
			"        n->next = head;",
			"        head = n;",
			"    }",
			"",
			"    bool search(int val) {",
			"        Node *temp = tail->next;",
			"        if (temp->data == val) {",
			"            return true;",
			"        }",
			"        temp = temp->next;",
			"        while (temp != tail->next) {",
			"            if (temp->data == val) {",
			"                return true;",
			"            }",
			"            temp = temp->next;",
			"        }",
			"        return false;",
			"    }",
			"",
			"    void display() {",
			"        Node *temp = tail->next;",
			"        cout << temp->data << endl;",
			"        temp = temp->next;",
			"        while (temp != tail->next) {",
			"            cout << temp->data << endl;",
			"            temp = temp->next;",
			"        }",
			"    }",
			"",
			"    void deleteAtFront() {",
			"        Node *temp = head;",
			"        tail->next = head->next;",
			"        head = head->next;",
			"        delete temp;",
			"    }",
			"",
			"    void deleteAtEnd() {",
			"        Node *curr = head;",
			"        Node *pre = NULL;",
			"        while (curr != tail) {",
			"            pre = curr;",
			"            curr = curr->next;",
			"        }",
			"        pre->next = tail->next;",
			"        tail = pre;",
			"        delete curr;",
			"    }",
			"",
			"    void insertAfterValue(int after, int val) {",
			"        Node *temp = head;",
			"        do {",
			"            if (temp->data == after) {",
			"                Node *n = new Node(val);",
			"                n->next = temp->next;",
			"                temp->next = n;",
			"                if (temp == tail) {",
			"                    tail = n;",
			"                }",
			"                return;",
			"            }",
			"            temp = temp->next;",
			"        } while (temp != head);",
			"        cout << \"Value \" << after << \" not found in the list.\" << endl;",
			"    }",
			"",
			"    void deleteAfterValue(int after) {",
			"        Node *temp = head;",
			"        do {",
			"            if (temp->data == after) {",
			"                Node *toDelete = temp->next;",
			"                if (toDelete == head) {",
			"                    deleteAtFront();",
			"                } else if (toDelete == tail) {",
			"                    deleteAtEnd();",
			"                } else {",
			"                    temp->next = toDelete->next;",
			"                    delete toDelete;",
			"                }",
			"                return;",
			"            }",
			"            temp = temp->next;",
			"        } while (temp != head);",
			"        cout << \"Value \" << after << \" not found in the list.\" << endl;",
			"    }",
			"};"
		],
		"description": "C++ Circular Linked List with insert, delete, search, and display functions."
	},
	"Node Class doubly": {
		"scope": "cpp",
		"prefix": "nodeclassdoubly",
		"body": [
			"class Node {",
			"public:",
			"    int data;",
			"    Node* next;",
			"    Node* prev;",
			"",
			"    Node(int val) {",
			"        data = val;",
			"        next = NULL;",
			"        prev = NULL;",
			"    }",
			"};"
		],
		"description": "A basic Node class for doubly linked lists."
	},
	"DoublyLinkedList Class": {
		"scope": "cpp",
		"prefix": "doublylinkedlistclass",
		"body": [
			"class DoublyLinkedList {",
			"public:",
			"    Node* head;",
			"    Node* tail;",
			"",
			"    DoublyLinkedList() {",
			"        head = NULL;",
			"        tail = NULL;",
			"    }",
			"",
			"    void insertAtEnd(int val) {",
			"        Node* n = new Node(val);",
			"        if (head == NULL) {",
			"            head = n;",
			"            tail = n;",
			"        } else {",
			"            tail->next = n;",
			"            n->prev = tail;",
			"            tail = n;",
			"        }",
			"    }",
			"",
			"    void insertAtFront(int val) {",
			"        Node* n = new Node(val);",
			"        if (head == NULL) {",
			"            head = n;",
			"            tail = n;",
			"        } else {",
			"            n->next = head;",
			"            head->prev = n;",
			"            head = n;",
			"        }",
			"    }",
			"",
			"    bool search(int val) {",
			"        Node* temp = head;",
			"        while (temp != NULL) {",
			"            if (temp->data == val)",
			"                return true;",
			"            temp = temp->next;",
			"        }",
			"        return false;",
			"    }",
			"",
			"    void display() {",
			"        Node* temp = head;",
			"        while (temp != NULL) {",
			"            cout << temp->data << \" \";",
			"            temp = temp->next;",
			"        }",
			"        cout << endl;",
			"    }",
			"",
			"    void deleteAtFront() {",
			"        if (head == NULL)",
			"            return;",
			"",
			"        Node* temp = head;",
			"        head = head->next;",
			"        if (head != NULL)",
			"            head->prev = NULL;",
			"        else",
			"            tail = NULL;",
			"        delete temp;",
			"    }",
			"",
			"    void deleteAtEnd() {",
			"        if (tail == NULL)",
			"            return;",
			"",
			"        Node* temp = tail;",
			"        tail = tail->prev;",
			"        if (tail != NULL)",
			"            tail->next = NULL;",
			"        else",
			"            head = NULL;",
			"        delete temp;",
			"    }",
			"",
			"    void deleteAtPos(int pos) {",
			"        if (head == NULL || pos <= 0) return;",
			"",
			"        Node* temp = head;",
			"",
			"        if (pos == 1) {",
			"            deleteAtFront();",
			"            return;",
			"        }",
			"",
			"        for (int i = 1; temp != NULL && i < pos; i++) {",
			"            temp = temp->next;",
			"        }",
			"",
			"        if (temp == NULL) return;",
			"",
			"        if (temp->next != NULL) temp->next->prev = temp->prev;",
			"        if (temp->prev != NULL) temp->prev->next = temp->next;",
			"",
			"        if (temp == tail) tail = temp->prev;",
			"",
			"        delete temp;",
			"    }",
			"",
			"    void insertAfterPos(int pos, int val) {",
			"        Node* n = new Node(val);",
			"        if (head == NULL && pos == 0) {",
			"            head = n;",
			"            tail = n;",
			"            return;",
			"        }",
			"",
			"        Node* temp = head;",
			"        for (int i = 1; temp != NULL && i < pos; i++) {",
			"            temp = temp->next;",
			"        }",
			"",
			"        if (temp == NULL) return;",
			"",
			"        n->next = temp->next;",
			"        n->prev = temp;",
			"",
			"        if (temp->next != NULL)",
			"            temp->next->prev = n;",
			"        temp->next = n;",
			"",
			"        if (n->next == NULL)",
			"            tail = n;",
			"    }",
			"};"
		],
		"description": "A doubly linked list class with methods to insert, delete, and search nodes."
	},
	"LinkedList Class with Loop Detection": {
		"scope": "cpp",
		"prefix": "linkedlistloopclass",
		"body": [
			"class LinkedList {",
			"public:",
			"    Node* head;",
			"",
			"    LinkedList() {",
			"        head = NULL;",
			"    }",
			"",
			"    void insertAtEnd(int val) {",
			"        Node* newNode = new Node(val);",
			"        if (head == NULL) {",
			"            head = newNode;",
			"        } else {",
			"            Node* temp = head;",
			"            while (temp->next != NULL) {",
			"                temp = temp->next;",
			"            }",
			"            temp->next = newNode;",
			"        }",
			"    }",
			"",
			"    bool detectLoop() {",
			"        Node* slow = head;",
			"        Node* fast = head;",
			"",
			"        while (fast != NULL && fast->next != NULL) {",
			"            slow = slow->next;",
			"            fast = fast->next->next;",
			"",
			"            if (slow == fast) {",
			"                return true;",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"",
			"    void createLoop(int pos) {",
			"        if (head == NULL) return;",
			"",
			"        Node* temp = head;",
			"        Node* loopNode = NULL;",
			"        int counter = 1;",
			"",
			"        while (temp->next != NULL) {",
			"            if (counter == pos) {",
			"                loopNode = temp;",
			"            }",
			"            temp = temp->next;",
			"            counter++;",
			"        }",
			"        temp->next = loopNode;",
			"    }",
			"};"
		],
		"description": "A LinkedList class with methods to insert nodes, detect loops, and create loops."
	},
	"Selection Sort": {
		"scope": "cpp",
		"prefix": "selectionsort",
		"body": [
			"void selection_sort(int *arr, int a, int b) {",
			"    if (a > b) {",
			"        swap(a, b);",
			"    }",
			"",
			"    int n = b;",
			"    for (int i = a; i < b - 1; i++) {",
			"        int min_index = i;",
			"        for (int j = i + 1; j < b; j++) {",
			"            if (arr[j] < arr[min_index]) {",
			"                min_index = j;",
			"            }",
			"        }",
			"",
			"        int temp = arr[i];",
			"        arr[i] = arr[min_index];",
			"        arr[min_index] = temp;",
			"    }",
			"}"
		],
		"description": "Selection sort algorithm for sorting part of an array between indices a and b."
	},
	"Insertion Sort": {
		"scope": "cpp",
		"prefix": "insertionsort",
		"body": [
			"void insertion_sort(int *array) {",
			"    for (int i = 0; i < 9; i++) {",
			"        int key = array[i];",
			"        int j = i - 1;",
			"        while (j >= 0 && array[j] > key) {",
			"            array[j + 1] = array[j];",
			"            j--;",
			"        }",
			"        array[j + 1] = key;",
			"    }",
			"    int bigValue = array[8];",
			"    for (int i = 8; i > 4; i--) {",
			"        array[i] = array[i - 1];",
			"    }",
			"    array[4] = bigValue;",
			"}"
		],
		"description": "Insertion sort algorithm with a custom shift for the largest value."
	},
	"Bubble Sort String Array": {
		"scope": "cpp",
		"prefix": "bubblesortstring",
		"body": [
			"void bubblesort_array_string(string array[], int n) {",
			"    for (int i = 0; i < n - 1; i++) {",
			"        for (int j = 0; j < n - i - 1; j++) {",
			"            if (array[j] > array[j + 1]) {",
			"                string temp = array[j];",
			"                array[j] = array[j + 1];",
			"                array[j + 1] = temp;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Bubble sort for sorting an array of strings."
	},
	"Shell Sort": {
		"scope": "cpp",
		"prefix": "shellsort",
		"body": [
			"void shell_sort(int *arr, int x) {",
			"    for (int gap = x / 2; gap > 0; gap /= 2) {",
			"        for (int j = gap; j < x; j++) {",
			"            int temp = arr[j];",
			"            int i = j;",
			"            while (i >= gap && arr[i - gap] > temp) {",
			"                arr[i] = arr[i - gap];",
			"                i -= gap;",
			"            }",
			"            arr[i] = temp;",
			"        }",
			"    }",
			"}"
		],
		"description": "Shell sort algorithm for sorting an integer array."
	},
	"Comb Sort": {
		"scope": "cpp",
		"prefix": "combsort",
		"body": [
			"int getNextGap(int gap) {",
			"    gap = (gap * 10) / 13;",
			"    if (gap < 1) ",
			"        return 1;",
			"    return gap;",
			"}",
			"",
			"void combSort(int arr[], int n) {",
			"    int gap = n;",
			"    bool swapped = true;",
			"",
			"    while (gap != 1 || swapped) {",
			"        gap = getNextGap(gap);",
			"        swapped = false;",
			"",
			"        for (int i = 0; i < n - gap; i++) {",
			"            if (arr[i] > arr[i + gap]) {",
			"                std::swap(arr[i], arr[i + gap]);",
			"                swapped = true;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Comb sort algorithm for sorting an integer array."
	},
	"Linear Search": {
		"scope": "cpp",
		"prefix": "linearsearch",
		"body": [
			"int linearSearch(int arr[], int n, int x) {",
			"    for (int i = 0; i < n; i++) {",
			"        if (arr[i] == x) {",
			"            return i;",
			"        }",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Linear search algorithm for finding an element in an array."
	},
	"Binary Search": {
		"scope": "cpp",
		"prefix": "binarysearch",
		"body": [
			"int binarySearch(int arr[], int l, int r, int x) {",
			"    while (l <= r) {",
			"        int mid = l + (r - l) / 2;",
			"",
			"        if (arr[mid] == x)",
			"            return mid;",
			"",
			"        if (arr[mid] < x)",
			"            l = mid + 1;",
			"        else",
			"            r = mid - 1;",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Binary search algorithm for finding an element in a sorted array."
	},
	"Interpolation Search": {
		"scope": "cpp",
		"prefix": "interpolationsearch",
		"body": [
			"int interpolationSearch(int arr[], int n, int x) {",
			"    int low = 0, high = n - 1;",
			"",
			"    while (low <= high && x >= arr[low] && x <= arr[high]) {",
			"        if (low == high) {",
			"            if (arr[low] == x) return low;",
			"            return -1;",
			"        }",
			"",
			"        int pos = low + ((double)(high - low) / (arr[high] - arr[low])) * (x - arr[low]);",
			"",
			"        if (arr[pos] == x)",
			"            return pos;",
			"",
			"        if (arr[pos] < x)",
			"            low = pos + 1;",
			"        else",
			"            high = pos - 1;",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Interpolation search algorithm for finding an element in a sorted array."
	},
	"N-Queens Solver": {
		"scope": "cpp",
		"prefix": "nqueenssolver",
		"body": [
			"#include <cmath>",
			"",
			"bool isSafe(int board[], int row, int col) {",
			"    for (int i = 0; i < row; i++) {",
			"        if (board[i] == col || abs(board[i] - col) == abs(i - row)) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"bool solveNQueens(int board[], int n, int row = 0) {",
			"    if (row == n) {",
			"        return true;",
			"    }",
			"    for (int col = 0; col < n; col++) {",
			"        if (isSafe(board, row, col)) {",
			"            board[row] = col;",
			"            if (solveNQueens(board, n, row + 1)) {",
			"                return true;",
			"            }",
			"            board[row] = -1;",
			"        }",
			"    }",
			"    return false;",
			"}"
		],
		"description": "N-Queens solver using backtracking."
	},
	"Find Length of Linked List": {
		"scope": "cpp",
		"prefix": "findlength_Llist",
		"body": [
			"int findLength(Node* node) {",
			"    if (node == NULL) {",
			"        return 0;",
			"    }",
			"    return 1 + findLength(node->next);",
			"}"
		],
		"description": "Recursively finds the length of a linked list."
	},
	"Find Value in Linked List (Recursion)": {
		"scope": "cpp",
		"prefix": "findvalue_Llist",
		"body": [
			"bool find_value_recursion(Node* current, int key) {",
			"    if (current == nullptr) {",
			"        cout << \"Value not in list\" << endl;",
			"        return false;",
			"    }",
			"    if (current->data == key) {",
			"        cout << \"Value found: \" << current->data << endl;",
			"        return true;",
			"    }",
			"    return find_value_recursion(current->next, key);",
			"}"
		],
		"description": "Recursively searches for a value in a linked list."
	},
	"Find Maze Exit": {
		"scope": "cpp",
		"prefix": "findmazeexit",
		"body": [
			"bool find_maze_exit(int maze[5][5], int i, int j, int lion[5][5]) {",
			"    if (i == 4 && j == 4) {",
			"        lion[i][j] = 1;",
			"        return true;",
			"    }",
			"",
			"    if (i < 0 || i >= 5 || j < 0 || j >= 5 || maze[i][j] == 0) {",
			"        return false;",
			"    }",
			"",
			"    lion[i][j] = 1;",
			"    if (find_maze_exit(maze, i + 1, j, lion)) {",
			"        return true;",
			"    }",
			"",
			"    if (find_maze_exit(maze, i, j + 1, lion)) {",
			"        return true;",
			"    }",
			"",
			"    lion[i][j] = 0;",
			"    return false;",
			"}"
		],
		"description": "Recursively finds the exit of a maze represented as a 2D array."
	},
	"Sort by Second Array Function": {
		"scope": "cpp",
		"prefix": "sortbysecondarray",
		"body": [
			"void sort_by_second_array(int array1[], int n, int array2[], int m) {",
			"    int result[n];",
			"    int index = 0;",
			"    for (int i = 0; i < m; i++) {",
			"        for (int j = 0; j < n; j++) {",
			"            if (array1[j] == array2[i]) {",
			"                result[index] = array1[j];",
			"                index++;",
			"            }",
			"        }",
			"    }",
			"    for (int j = 0; j < n; j++) {",
			"        bool isthere = false;",
			"        for (int i = 0; i < m; i++) {",
			"            if (array1[j] == array2[i]) {",
			"                isthere = true;",
			"                break;",
			"            }",
			"        }",
			"        if (!isthere) {",
			"            result[index] = array1[j];",
			"            index++;",
			"        }",
			"    }",
			"    cout << \"Sorted array: \";",
			"    for (int i = 0; i < n; i++) {",
			"        cout << result[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}"
		],
		"description": "Function to sort one array based on the order of elements in a second array"
	},
	"Stack Class Implementation": {
		"scope": "cpp",
		"prefix": "stackclass",
		"body": [
			"class Stack {",
			"    int top;",
			"",
			"public:",
			"    int a[MAX];",
			"",
			"    Stack() { top = -1; }",
			"    int get_top() { return top; }",
			"",
			"    void push(int x) {",
			"        if (top >= (MAX - 1)) {",
			"            cout << \"Stack Overflow\\n\";",
			"            exit(1);",
			"        } else {",
			"            a[++top] = x;",
			"            cout << x << \" pushed!\\n\";",
			"        }",
			"    }",
			"",
			"    int pop() {",
			"        if (top < 0) {",
			"            cout << \"Stack Underflow\\n\";",
			"            return -1;",
			"        } else {",
			"            int x = a[top--];",
			"            cout << x << \" removed!\\n\";",
			"            return x;",
			"        }",
			"    }",
			"",
			"    int peek() {",
			"        if (top < 0) {",
			"            cout << \"Stack is Empty\\n\";",
			"            return 0;",
			"        } else {",
			"            return a[top];",
			"        }",
			"    }",
			"",
			"    bool isEmpty() {",
			"        return (top < 0);",
			"    }",
			"",
			"    void display() {",
			"        if (top < 0)",
			"            cout << \"Stack is Empty\\n\";",
			"        else {",
			"            cout << \"Stack Elements: \";",
			"            for (int i = 0; i <= top; i++) {",
			"                if (i == 0)",
			"                    cout << \"[\";",
			"                cout << a[i];",
			"                if (i < top)",
			"                    cout << \"->\";",
			"                if (i == top)",
			"                    cout << \"]\";",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"};"
		],
		"description": "A basic Stack class implementation in C++ with push, pop, peek, display, and isEmpty functions."
	},
	"Queue Class Implementation": {
		"scope": "cpp",
		"prefix": "queueclass",
		"body": [
			"class Queue {",
			"    int first;",
			"    int last;",
			"    int size;",
			"    int *arr;",
			"",
			"public:",
			"    Queue(int n) {",
			"        first = -1;",
			"        last = -1;",
			"        size = n;",
			"        arr = new int[size];",
			"    }",
			"",
			"    ~Queue() {",
			"        delete[] arr;",
			"    }",
			"",
			"    void enqueue(int data) {",
			"        if (isFull()) {",
			"            cout << \"FULL!!\\n\";",
			"            exit(1);",
			"        } else if (isEmpty())",
			"            first = last = 0;",
			"        else",
			"            last++;",
			"        cout << data << \" queued!\\n\";",
			"        arr[last] = data;",
			"    }",
			"",
			"    int dequeue() {",
			"        if (isEmpty()) {",
			"            cout << \"Queue is Empty!\\n\";",
			"            return 0;",
			"        } else {",
			"            int data = arr[first];",
			"            if (first == last)",
			"                first = last = -1;",
			"            else",
			"                first++;",
			"            cout << data << \" dequeued!\\n\";",
			"            return data;",
			"        }",
			"    }",
			"",
			"    bool isFull() {",
			"        if (last == size - 1)",
			"            return true;",
			"        else",
			"            return false;",
			"    }",
			"",
			"    bool isEmpty() {",
			"        if (first == -1 || first > last)",
			"            return true;",
			"        else",
			"            return false;",
			"    }",
			"};"
		],
		"description": "A basic Queue class implementation in C++ with enqueue, dequeue, isFull, and isEmpty functions."
	},
	"Reverse Stack Function": {
		"scope": "cpp",
		"prefix": "reversestack",
		"body": [
			"Stack reverseStack(Stack s) {",
			"    Queue q1(s.get_top() + 1);",
			"",
			"    while (!s.isEmpty())",
			"        q1.enqueue(s.pop());",
			"",
			"    while (!q1.isEmpty())",
			"        s.push(q1.dequeue());",
			"",
			"    return s;",
			"}"
		],
		"description": "Function to reverse a stack using a queue in C++"
	},
	"CircularQueue Class Implementation": {
		"scope": "cpp",
		"prefix": "circularqueue",
		"body": [
			"class CircularQueue {",
			"    int first;",
			"    int last;",
			"    int size;",
			"    int *arr;",
			"",
			"public:",
			"    CircularQueue(int n) {",
			"        first = -1;",
			"        last = -1;",
			"        size = n;",
			"        arr = new int[size];",
			"    }",
			"",
			"    ~CircularQueue() {",
			"        delete[] arr;",
			"    }",
			"",
			"    void enqueue(int data) {",
			"        if (isFull()) {",
			"            cout << \"Queue is Full!\\n\";",
			"            return;",
			"        } else if (isEmpty()) {",
			"            first = last = 0;",
			"        } else {",
			"            last = (last + 1) % size;",
			"        }",
			"        arr[last] = data;",
			"        cout << data << \" queued!\\n\";",
			"    }",
			"",
			"    int dequeue() {",
			"        if (isEmpty()) {",
			"            cout << \"Queue is Empty!\\n\";",
			"            return -1;",
			"        }",
			"",
			"        int data = arr[first];",
			"        if (first == last) {",
			"            first = last = -1;",
			"        } else {",
			"            first = (first + 1) % size;",
			"        }",
			"        cout << data << \" dequeued!\\n\";",
			"        return data;",
			"    }",
			"",
			"    bool isFull() {",
			"        return (last + 1) % size == first;",
			"    }",
			"",
			"    bool isEmpty() {",
			"        return first == -1;",
			"    }",
			"};"
		],
		"description": "A Circular Queue class implementation in C++ with enqueue, dequeue, isFull, and isEmpty functions."
	},
	"Infix to Postfix Conversion": {
		"scope": "cpp",
		"prefix": "infixtopostfix",
		"body": [
			"int precedence(char c) {",
			"    if (c == '^')",
			"        return 3;",
			"    else if (c == '*' || c == '/')",
			"        return 2;",
			"    else if (c == '+' || c == '-')",
			"        return 1;",
			"    else",
			"        return -1;",
			"}",
			"",
			"string infixToPostfix(string infix) {",
			"    string postfix = \"\";",
			"    Stack s;",
			"",
			"    for (int i = 0; i < infix.length(); i++) {",
			"        char c = infix[i];",
			"",
			"        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {",
			"            postfix += c;",
			"        } else if (c == '(') {",
			"            s.push(c);",
			"        } else if (c == ')') {",
			"            while (!s.isEmpty() && s.peek() != '(') {",
			"                postfix += s.pop();",
			"            }",
			"            if (!s.isEmpty() && s.peek() == '(') {",
			"                s.pop();",
			"            }",
			"        } else {",
			"            while (!s.isEmpty() && precedence(c) <= precedence(s.peek())) {",
			"                postfix += s.pop();",
			"            }",
			"            s.push(c);",
			"        }",
			"    }",
			"",
			"    while (!s.isEmpty()) {",
			"        postfix += s.pop();",
			"    }",
			"",
			"    return postfix;",
			"}"
		],
		"description": "C++ implementation for infix to postfix conversion."
	},
	"Linked List Based Queue": {
		"scope": "cpp",
		"prefix": "linkedqueue",
		"body": [
			"class Node {",
			"public:",
			"    int data;",
			"    Node* next;",
			"",
			"    Node(int value) {",
			"        data = value;",
			"        next = nullptr;",
			"    }",
			"};",
			"",
			"class Queue {",
			"private:",
			"    Node* front;",
			"    Node* rear;",
			"",
			"public:",
			"    Queue() {",
			"        front = rear = nullptr;",
			"    }",
			"",
			"    void enqueue(int value) {",
			"        Node* temp = new Node(value);",
			"        if (rear == nullptr) {",
			"            front = rear = temp;",
			"            cout << value << \" enqueued!\\n\";",
			"            return;",
			"        }",
			"        rear->next = temp;",
			"        rear = temp;",
			"        cout << value << \" enqueued!\\n\";",
			"    }",
			"",
			"    void dequeue() {",
			"        if (front == nullptr) {",
			"            cout << \"Queue is empty, cannot dequeue.\\n\";",
			"            return;",
			"        }",
			"        Node* temp = front;",
			"        front = front->next;",
			"        if (front == nullptr)",
			"            rear = nullptr;",
			"        cout << temp->data << \" dequeued!\\n\";",
			"        delete temp;",
			"    }",
			"",
			"    int peek() {",
			"        if (front == nullptr) {",
			"            cout << \"Queue is empty.\\n\";",
			"            return -1;",
			"        }",
			"        return front->data;",
			"    }",
			"",
			"    bool isEmpty() {",
			"        return front == nullptr;",
			"    }",
			"",
			"    void display() {",
			"        if (isEmpty()) {",
			"            cout << \"Queue is empty.\\n\";",
			"            return;",
			"        }",
			"        Node* temp = front;",
			"        cout << \"Queue elements: \";",
			"        while (temp != nullptr) {",
			"            cout << temp->data << \" \";",
			"            temp = temp->next;",
			"        }",
			"        cout << endl;",
			"    }",
			"};"
		],
		"description": "C++ Queue implementation using linked list nodes."
	},
	"Linked List Based Stack": {
		"scope": "cpp",
		"prefix": "linkedstack",
		"body": [
			"class Node {",
			"public:",
			"    int data;",
			"    Node* next;",
			"    Node(int value) : data(value), next(nullptr) {}",
			"};",
			"",
			"class Stack {",
			"private:",
			"    Node* top;",
			"public:",
			"    Stack() : top(nullptr) {}",
			"",
			"    void push(int value) {",
			"        Node* temp = new Node(value);",
			"        temp->next = top;",
			"        top = temp;",
			"        cout << value << \" pushed to stack!\\n\";",
			"    }",
			"",
			"    void pop() {",
			"        if (top == nullptr) {",
			"            cout << \"Stack Underflow\\n\";",
			"            return;",
			"        }",
			"        Node* temp = top;",
			"        top = top->next;",
			"        cout << temp->data << \" popped from stack!\\n\";",
			"        delete temp;",
			"    }",
			"",
			"    int peek() {",
			"        if (top == nullptr) {",
			"            cout << \"Stack is empty\\n\";",
			"            return -1;",
			"        }",
			"        return top->data;",
			"    }",
			"",
			"    bool isEmpty() {",
			"        return top == nullptr;",
			"    }",
			"",
			"    void display() {",
			"        if (top == nullptr) {",
			"            cout << \"Stack is empty\\n\";",
			"            return;",
			"        }",
			"        Node* temp = top;",
			"        cout << \"Stack elements: \";",
			"        while (temp != nullptr) {",
			"            cout << temp->data << \" \";",
			"            temp = temp->next;",
			"        }",
			"        cout << endl;",
			"    }",
			"};"
		],
		"description": "C++ Stack implementation using linked list nodes."
	},
	"Merge Sort Algorithm": {
		"scope": "cpp",
		"prefix": "mergesort",
		"body": [
			"void merge(int a[], int beg, int mid, int end) {",
			"    int i, j, k;",
			"    int n1 = mid - beg + 1;",
			"    int n2 = end - mid;",
			"    int LeftArray[n1], RightArray[n2];",
			"    for (int i = 0; i < n1; i++)",
			"        LeftArray[i] = a[beg + i];",
			"    for (int j = 0; j < n2; j++)",
			"        RightArray[j] = a[mid + 1 + j];",
			"    i = 0;",
			"    j = 0;",
			"    k = beg;",
			"    while (i < n1 && j < n2) {",
			"        if (LeftArray[i] <= RightArray[j]) {",
			"            a[k] = LeftArray[i];",
			"            i++;",
			"        } else {",
			"            a[k] = RightArray[j];",
			"            j++;",
			"        }",
			"        k++;",
			"    }",
			"    while (i < n1) {",
			"        a[k] = LeftArray[i];",
			"        i++;",
			"        k++;",
			"    }",
			"    while (j < n2) {",
			"        a[k] = RightArray[j];",
			"        j++;",
			"        k++;",
			"    }",
			"}",
			"void mergeSort(int a[], int beg, int end) {",
			"    if (beg < end) {",
			"        int mid = (beg + end) / 2;",
			"        mergeSort(a, beg, mid);",
			"        mergeSort(a, mid + 1, end);",
			"        merge(a, beg, mid, end);",
			"    }",
			"}"
		],
		"description": "C++ Merge Sort Algorithm without comments."
	},
	"Quick Sort Algorithm": {
		"scope": "cpp",
		"prefix": "quicksort",
		"body": [
			"int partition(int a[], int start, int end) {",
			"    int pivot = a[end];",
			"    int i = start - 1;",
			"    for (int j = start; j < end; j++) {",
			"        if (a[j] <= pivot) {",
			"            i++;",
			"            int t = a[i];",
			"            a[i] = a[j];",
			"            a[j] = t;",
			"        }",
			"    }",
			"    int t = a[i + 1];",
			"    a[i + 1] = a[end];",
			"    a[end] = t;",
			"    return i + 1;",
			"}",
			"void quick(int a[], int start, int end) {",
			"    if (start < end) {",
			"        int p = partition(a, start, end);",
			"        quick(a, start, p - 1);",
			"        quick(a, p + 1, end);",
			"    }",
			"}"
		],
		"description": "C++ Quick Sort Algorithm without comments."
	},
	"Radix Sort Algorithm": {
		"scope": "cpp",
		"prefix": "radixsort",
		"body": [
			"int getMax(int a[], int n) {",
			"   int max = a[0];",
			"   for (int i = 1; i < n; i++) {",
			"      if (a[i] > max)",
			"         max = a[i];",
			"   }",
			"   return max;",
			"}",
			"void countingSort(int a[], int n, int place) {",
			"   int output[n + 1];",
			"   int count[10] = {0};",
			"   for (int i = 0; i < n; i++)",
			"      count[(a[i] / place) % 10]++;",
			"   for (int i = 1; i < 10; i++)",
			"      count[i] += count[i - 1];",
			"   for (int i = n - 1; i >= 0; i--) {",
			"      output[count[(a[i] / place) % 10] - 1] = a[i];",
			"      count[(a[i] / place) % 10]--;",
			"   }",
			"   for (int i = 0; i < n; i++)",
			"      a[i] = output[i];",
			"}",
			"void radixsort(int a[], int n) {",
			"   int max = getMax(a, n);",
			"   for (int place = 1; max / place > 0; place *= 10)",
			"      countingSort(a, n, place);",
			"}"
		],
		"description": "C++ Radix Sort Algorithm without comments."
	},
	"Print Array Function": {
		"scope": "cpp",
		"prefix": "printarray",
		"body": [
			"void printArray(int a[], int n) {",
			"   for (int i = 0; i < n; ++i) {",
			"      cout << a[i] << \" \";",
			"   }",
			"   cout << \"\\n\";",
			"}"
		],
		"description": "C++ function to print array elements."
	},
	"Overloaded [] Operator": {
		"scope": "cpp",
		"prefix": "overload_operatorbracket",
		"body": [
			"int & operator[](int index) {",
			"    Node* temp = head;",
			"    int count = 0;",
			"    while(temp) {",
			"        if (count == index) {",
			"            return temp->data;",
			"        }",
			"        temp = temp->next;",
			"        count++;",
			"    }",
			"    throw out_of_range(\"Index out of bounds\");",
			"}"
		],
		"description": "C++ overloaded [] operator for linked list node access by index."
	},
	"Binary Search Linked List": {
		"scope": "cpp",
		"prefix": "binarysearch_Llist",
		"body": [
			"Node* binarySearchLinkedList(Node* head, int target) {",
			"    Node* start = head;",
			"    Node* end = NULL;",
			"",
			"    do {",
			"        Node* mid = findMiddle(start, end);",
			"",
			"        if (mid == NULL) return NULL;",
			"",
			"        if (mid->data == target)",
			"            return mid;",
			"        else if (mid->data < target)",
			"            start = mid->next;",
			"        else",
			"            end = mid;",
			"    } while (end == NULL || end != start);",
			"",
			"    return NULL;",
			"}"
		],
		"description": "Performs binary search on a sorted linked list to find a target value."
	},
	"Get Size Singly Linked List": {
		"scope": "cpp",
		"prefix": "getsize_sll",
		"body": [
			"int getSizeSinglyLinkedList(Node* head) {",
			"    int size = 0;",
			"    Node* current = head;",
			"    while (current != NULL) {",
			"        size++;",
			"        current = current->next;",
			"    }",
			"    return size;",
			"}"
		],
		"description": "Calculates the size of a singly linked list."
	},
	"Get Size Doubly Linked List": {
		"scope": "cpp",
		"prefix": "getsize_dll",
		"body": [
			"int getSizeDoublyLinkedList(DoublyNode* head) {",
			"    int size = 0;",
			"    DoublyNode* current = head;",
			"    while (current != NULL) {",
			"        size++;",
			"        current = current->next;",
			"    }",
			"    return size;",
			"}"
		],
		"description": "Calculates the size of a doubly linked list."
	},
	"Get Size Circular Linked List": {
		"scope": "cpp",
		"prefix": "getsize_cll",
		"body": [
			"int getSizeCircularLinkedList(Node* head) {",
			"    if (head == NULL) return 0;",
			"",
			"    int size = 0;",
			"    Node* current = head;",
			"    do {",
			"        size++;",
			"        current = current->next;",
			"    } while (current != head);",
			"    ",
			"    return size;",
			"}"
		],
		"description": "Calculates the size of a circular linked list."
	},
	"Get Size Doubly Circular Linked List": {
		"scope": "cpp",
		"prefix": "getsize_dcll",
		"body": [
			"int getSizeDoublyCircularLinkedList(DoublyNode* head) {",
			"    if (head == NULL) return 0;",
			"",
			"    int size = 0;",
			"    DoublyNode* current = head;",
			"    do {",
			"        size++;",
			"        current = current->next;",
			"    } while (current != head);",
			"    ",
			"    return size;",
			"}"
		],
		"description": "Calculates the size of a doubly circular linked list."
	},
	"Word Search in 2D Array": {
		"scope": "cpp",
		"prefix": "wordsearch_2d",
		"body": [
			"#include<iostream>",
			"using namespace std;",
			"",
			"bool search(char arr[5][6], string word, int &start_i, int &start_j, int n, int m, int i, int j, int k) {",
			"    if (k == word.size()) return true;",
			"    if (i < 0 || j < 0 || i >= n || j >= m || arr[i][j] != word[k])",
			"        return false;",
			"",
			"    char ch = arr[i][j];",
			"    arr[i][j] = '#';",
			"",
			"    bool found = search(arr, word, start_i, start_j, n, m, i + 1, j, k + 1) ||",
			"                 search(arr, word, start_i, start_j, n, m, i, j + 1, k + 1) ||",
			"                 search(arr, word, start_i, start_j, n, m, i - 1, j, k + 1) ||",
			"                 search(arr, word, start_i, start_j, n, m, i, j - 1, k + 1);",
			"",
			"    arr[i][j] = ch;",
			"    return found;",
			"}",
			"",
			"bool present(char arr[5][6], string word, int n, int m, int &start_i, int &start_j) {",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < m; j++) {",
			"            if (arr[i][j] == word[0]) {",
			"                start_i = i;",
			"                start_j = j;",
			"                if (search(arr, word, start_i, start_j, n, m, i, j, 0)) {",
			"                    return true;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return false;",
			"}",
			"",
			"int main() {",
			"    int n = 5;",
			"    int m = 6;",
			"",
			"    char arr[5][6] = {",
			"        {'g', 'a', 'k', 'i', 'w', 'i'},",
			"        {'r', 'p', 'o', 'p', 'l', 'a'},",
			"        {'a', 'p', 'a', 'p', 'b', 'a'},",
			"        {'p', 'l', 'e', 'm', 'o', 'n'},",
			"        {'e', 'e', 'e', 'p', 'b', 'p'},",
			"    };",
			"",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < m; j++) {",
			"            cout << arr[i][j] << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"",
			"    string words[6] = {\"apple\",\"lemon\",\"banana\",\"kiwi\",\"papaya\",\"grape\"};",
			"",
			"    for (int i = 0; i < 6; i++) {",
			"        int start_i = -1, start_j = -1;",
			"        if (present(arr, words[i], n, m, start_i, start_j)) {",
			"            cout << words[i] << \": (\"<< start_i << \", \" << start_j << \")\" << endl;",
			"        } else {",
			"            cout << 'n' << endl;",
			"        }",
			"    }",
			"",
			"    return 0;",
			"}"
		],
		"description": "Find words in a 2D array (word search)"
	},
	"CountPaths Function": {
		"scope": "cpp",
		"prefix": "countpaths",
		"body": [
			"const int MAX = 100; ",
			"",
			"int maze[MAX][MAX];",
			"int N, M; ",
			"",
			"bool isSafe(int x, int y) {",
			"    return (x >= 0 && x < N && y >= 0 && y < M && maze[x][y] == 0);",
			"}",
			"",
			"int countPaths(int x, int y) {",
			"    if (x == N - 1 && y == M - 1) {",
			"        return 1;",
			"    }",
			"",
			"    int pathCount = 0;",
			"",
			"    if (isSafe(x + 1, y)) {",
			"        pathCount += countPaths(x + 1, y);",
			"    }",
			"",
			"    if (isSafe(x, y + 1)) {",
			"        pathCount += countPaths(x, y + 1);",
			"    }",
			"",
			"    return pathCount;",
			"}"
		],
		"description": "Function to count the number of paths in a maze"
	},
	"IsPalindromeSingly Function": {
		"scope": "cpp",
		"prefix": "ispalindromesingly",
		"body": [
			"bool isPalindromeSingly(Node* head) {",
			"    if (head == nullptr || head->next == nullptr) return true;",
			"",
			"    Node* slow = head;",
			"    Node* fast = head;",
			"    while (fast != nullptr && fast->next != nullptr) {",
			"        slow = slow->next;",
			"        fast = fast->next->next;",
			"    }",
			"",
			"    Node* secondHalf = reverse(slow);",
			"    Node* firstHalf = head;",
			"",
			"    while (secondHalf != nullptr) {",
			"        if (firstHalf->data != secondHalf->data) return false;",
			"        firstHalf = firstHalf->next;",
			"        secondHalf = secondHalf->next;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Function to check if a singly linked list is a palindrome"
	},
	"IsPalindromeDoubly Function": {
		"scope": "cpp",
		"prefix": "ispalindromedoubly",
		"body": [
			"bool isPalindromeDoubly(DoublyNode* head) {",
			"    if (head == nullptr || head->next == nullptr) return true;",
			"",
			"    DoublyNode* start = head;",
			"    DoublyNode* end = head;",
			"",
			"    while (end->next != nullptr) {",
			"        end = end->next;",
			"    }",
			"",
			"    while (start != end && end->next != start) {",
			"        if (start->data != end->data) return false;",
			"        start = start->next;",
			"        end = end->prev;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Function to check if a doubly linked list is a palindrome"
	},
	"IsPalindromeCircular Function": {
		"scope": "cpp",
		"prefix": "ispalindromecircular",
		"body": [
			"bool isPalindromeCircular(Node* head) {",
			"    if (head == nullptr || head->next == head) return true;",
			"",
			"    Node* slow = head;",
			"    Node* fast = head;",
			"    do {",
			"        fast = fast->next->next;",
			"        slow = slow->next;",
			"    } while (fast != head && fast->next != head);",
			"",
			"    Node* secondHalf = reverse(slow);",
			"",
			"    Node* start = head;",
			"    do {",
			"        if (start->data != secondHalf->data) return false;",
			"        start = start->next;",
			"        secondHalf = secondHalf->next;",
			"    } while (start != head);",
			"",
			"    return true;",
			"}"
		],
		"description": "Function to check if a circular singly linked list is a palindrome"
	},
	"IsPalindromeStackArray Function": {
		"scope": "cpp",
		"prefix": "ispalindromestackarray",
		"body": [
			"bool isPalindromeStackArray(int arr[], int size) {",
			"    int stack[size];",
			"    int top = -1;",
			"",
			"    for (int i = 0; i < size; i++) {",
			"        stack[++top] = arr[i];",
			"    }",
			"",
			"    for (int i = 0; i < size; i++) {",
			"        if (arr[i] != stack[top--]) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Function to check if an array is a palindrome using a stack"
	},
	"IsPalindromeQueueArray Function": {
		"scope": "cpp",
		"prefix": "ispalindromequeuearray",
		"body": [
			"bool isPalindromeQueueArray(int arr[], int size) {",
			"    int front = 0;",
			"    int rear = size - 1;",
			"",
			"    while (front < rear) {",
			"        if (arr[front] != arr[rear]) {",
			"            return false;",
			"        }",
			"        front++;",
			"        rear--;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Function to check if an array is a palindrome using a queue-like comparison"
	},
	"IsPalindromeStackLinkedList Function": {
		"scope": "cpp",
		"prefix": "ispalindromestacklinkedlist",
		"body": [
			"bool isPalindromeStackLinkedList(int arr[], int size) {",
			"    StackLinkedList stack;",
			"",
			"    for (int i = 0; i < size; i++) {",
			"        stack.push(arr[i]);",
			"    }",
			"",
			"    for (int i = 0; i < size; i++) {",
			"        if (arr[i] != stack.pop()) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Function to check if an array is a palindrome using a stack implemented as a linked list"
	},
	"IsPalindromeQueueLinkedList Function": {
		"scope": "cpp",
		"prefix": "ispalindromequeuelinkedlist",
		"body": [
			"bool isPalindromeQueueLinkedList(int arr[], int size) {",
			"    QueueLinkedList queue;",
			"",
			"    for (int i = 0; i < size; i++) {",
			"        queue.enqueue(arr[i]);",
			"    }",
			"",
			"    for (int i = size - 1; i >= 0; i--) {",
			"        if (arr[i] != queue.dequeue()) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Function to check if an array is a palindrome using a queue implemented as a linked list"
	},
	"SwapNodes Function": {
		"scope": "cpp",
		"prefix": "swapnodes_Llist",
		"body": [
			"void swapNodes(int val1, int val2) {",
			"    if (val1 == val2) {",
			"        return;",
			"    }",
			"",
			"    Node *prev1 = nullptr, *prev2 = nullptr;",
			"    Node *node1 = head, *node2 = head;",
			"",
			"    while (node1 != nullptr && node1->data != val1) {",
			"        prev1 = node1;",
			"        node1 = node1->next;",
			"    }",
			"",
			"    while (node2 != nullptr && node2->data != val2) {",
			"        prev2 = node2;",
			"        node2 = node2->next;",
			"    }",
			"",
			"    if (node1 == nullptr || node2 == nullptr) {",
			"        cout << \"One or both elements not found\" << endl;",
			"        return;",
			"    }",
			"",
			"    if (prev1 != nullptr) {",
			"        prev1->next = node2;",
			"    } else {",
			"        head = node2;",
			"    }",
			"",
			"    if (prev2 != nullptr) {",
			"        prev2->next = node1;",
			"    } else {",
			"        head = node1;",
			"    }",
			"",
			"    Node *temp = node1->next;",
			"    node1->next = node2->next;",
			"    node2->next = temp;",
			"}"
		],
		"description": "Function to swap two nodes in a singly linked list given their values."
	},
	"ReverseLinkedList Function": {
		"scope": "cpp",
		"prefix": "reverseLinkedList",
		"body": [
			"void reverseLinkedList() {",
			"    Node* prev = nullptr;",
			"    Node* current = head;",
			"    Node* next = nullptr;",
			"",
			"    while (current != nullptr) {",
			"        next = current->next;",
			"        current->next = prev;",
			"        prev = current;",
			"        current = next;",
			"    }",
			"",
			"    head = prev;",
			"}"
		],
		"description": "Function to reverse a singly linked list."
	},
	"Reverse Function": {
		"scope": "cpp",
		"prefix": "reverseFunction_Llist",
		"body": [
			"Node* reverse(Node* head) {",
			"    Node* prev = nullptr;",
			"    Node* curr = head;",
			"    Node* next = nullptr;",
			"",
			"    while (curr != nullptr) {",
			"        next = curr->next;",
			"        curr->next = prev;",
			"        prev = curr;",
			"        curr = next;",
			"    }",
			"    return prev;",
			"}"
		],
		"description": "Function to reverse a singly linked list and return the new head."
	},
	"Is Palindrome Function": {
		"scope": "cpp",
		"prefix": "isPalindromeFunction_Start_end",
		"body": [
			"bool isPalindrome(Node* start, Node* end) {",
			"    while (start != end && start->next != end) {",
			"        if (start->data != end->data) {",
			"            return false;",
			"        }",
			"        start = start->next;",
			"        end = end->next;",
			"        if (end->next == nullptr) {",
			"            break;",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Checks if the nodes between 'start' and 'end' form a palindrome."
	},
	"Find Largest Palindrome Function": {
		"scope": "cpp",
		"prefix": "findLargestPalindromeFunction",
		"body": [
			"void findLargestPalindrome() {",
			"    Node *start, *end;",
			"    int maxLength = 0;",
			"    string largestPalindrome = \"\";",
			"",
			"    for (start = head; start != nullptr; start = start->next) {",
			"        end = start;",
			"        while (end != nullptr) {",
			"            if (isPalindrome(start, end)) {",
			"                int length = 0;",
			"                Node *temp = start;",
			"                string currentPalindrome = \"\";",
			"                while (temp != end->next) {",
			"                    currentPalindrome += to_string(temp->data);",
			"                    length++;",
			"                    temp = temp->next;",
			"                }",
			"",
			"                if (length > maxLength) {",
			"                    maxLength = length;",
			"                    largestPalindrome = currentPalindrome;",
			"                }",
			"            }",
			"            end = end->next;",
			"        }",
			"    }",
			"",
			"    if (largestPalindrome.empty()) {",
			"        cout << \"No palindrome found.\" << endl;",
			"    } else {",
			"        cout << \"Largest Palindrome: \" << largestPalindrome << endl;",
			"    }",
			"}"
		],
		"description": "Finds and prints the largest palindrome in the linked list."
	},
	"Word Break Function": {
		"scope": "cpp",
		"prefix": "wordBreakFunction",
		"body": [
			"bool word_exist(string word, string *word_dict, int dict_size) {",
			"    for (int i = 0; i < dict_size; i++) {",
			"        if (word_dict[i] == word)",
			"            return true;",
			"    }",
			"    return false;",
			"}",
			"",
			"bool check_segmentation(string s, int index, string *word_dict, int dict_size) {",
			"    if (index == s.length())",
			"        return true;",
			"    for (int i = index + 1; i <= s.length(); i++) {",
			"        string word = s.substr(index, i - index);",
			"        if (word_exist(word, word_dict, dict_size))",
			"            if (check_segmentation(s, i, word_dict, dict_size))",
			"                return true;",
			"    }",
			"    return false;",
			"}",
			"",
			"bool word_break(string s, string *word_dict, int dict_size) {",
			"    return check_segmentation(s, 0, word_dict, dict_size);",
			"}"
		],
		"description": "A function to check if a string can be segmented into words from a given dictionary."
	},
	"Permutation Generator": {
		"scope": "cpp",
		"prefix": "generatePermutations",
		"body": [
			"void swap(char &a, char &b) {",
			"    char temp = a;",
			"    a = b;",
			"    b = temp;",
			"}",
			"",
			"void generatePermutations(vector<char> &letters, int start, int end) {",
			"    if (start == end) {",
			"        for (char letter : letters) {",
			"            cout << letter;",
			"        }",
			"        cout << \" \";",
			"    } else {",
			"        for (int i = start; i <= end; i++) {",
			"            swap(letters[start], letters[i]);",
			"            generatePermutations(letters, start + 1, end);",
			"            swap(letters[start], letters[i]);",
			"        }",
			"    }",
			"}",
			"",
			"void printPermutations(int n) {",
			"    vector<char> letters;",
			"    for (int i = 0; i < n; ++i) {",
			"        letters.push_back('a' + i);",
			"    }",
			"    ",
			"    cout << \"n=\" << n << endl;",
			"    generatePermutations(letters, 0, n - 1);",
			"    cout << endl;",
			"}"
		],
		"description": "Generates all permutations of the first n lowercase letters."
	},
	"Search and Insert Function": {
		"scope": "cpp",
		"prefix": "searchinsertBST",
		"body": [
			"void search_insert(int val) {",
			"    Node* newNode = new Node(val);",
			"    if (root == nullptr) {",
			"        root = newNode;",
			"        return;",
			"    }",
			"    Node* curr = root;",
			"    Node* par = nullptr;",
			"",
			"    while (curr != nullptr && curr->data != val) {",
			"        par = curr;",
			"        if (val < curr->data) {",
			"            curr = curr->left;",
			"        } else {",
			"            curr = curr->right;",
			"        }",
			"    }",
			"",
			"    if (curr != nullptr && val == curr->data) {",
			"        cout << val << \" is found in the tree\" << endl;",
			"    } else if (val < par->data) {",
			"        cout << val << \" is not found in the tree, added\" << endl;",
			"        par->left = newNode;",
			"    } else {",
			"        cout << val << \" is not found in the tree, added\" << endl;",
			"        par->right = newNode;",
			"    }",
			"}"
		],
		"description": "Search for a value in a Binary Search Tree and insert it if not found."
	},
	"Check if Tree is BST": {
		"scope": "cpp",
		"prefix": "isbstcheck",
		"body": [
			"bool isBST() {",
			"    return isBST(root, nullptr, nullptr);",
			"}",
			"",
			"bool isBST(Node* node, Node* minNode, Node* maxNode) {",
			"    if (node == nullptr) {",
			"        return true;",
			"    }",
			"",
			"    if ((minNode && node->data <= minNode->data) || (maxNode && node->data >= maxNode->data)) {",
			"        return false;",
			"    }",
			"",
			"    return isBST(node->left, minNode, node) && isBST(node->right, node, maxNode);",
			"}"
		],
		"description": "Function to check if a Binary Tree is a Binary Search Tree (BST)."
	},
	"Binary Search Tree Implementation": {
		"scope": "cpp",
		"prefix": "bstimplementation",
		"body": [
			"class Node {",
			"    public:",
			"        int data;",
			"        Node* left;",
			"        Node* right;",
			"        Node(int d): data(d), left(nullptr), right(nullptr) {}",
			"};",
			"",
			"class Tree {",
			"    Node* root;",
			"",
			"    public:",
			"        Tree(): root(nullptr) {}",
			"",
			"        Node* getroot() {",
			"            return root;",
			"        }",
			"",
			"        void insert(int val) {",
			"            Node* newNode = new Node(val);",
			"            if (root == nullptr) {",
			"                root = newNode;",
			"                return;",
			"            }",
			"            Node* curr = root;",
			"            Node* par = nullptr;",
			"",
			"            while (curr != nullptr) {",
			"                par = curr;",
			"                if (val < curr->data) {",
			"                    curr = curr->left;",
			"                } else {",
			"                    curr = curr->right;",
			"                }",
			"            }",
			"",
			"            if (val < par->data) {",
			"                par->left = newNode;",
			"            } else {",
			"                par->right = newNode;",
			"            }",
			"        }",
			"",
			"        void inorder() {",
			"            inorder(root);",
			"        }",
			"",
			"        void inorder(Node* root) {",
			"            if (root == nullptr) {",
			"                return;",
			"            }",
			"            inorder(root->left);",
			"            cout << root->data << \" \";",
			"            inorder(root->right);",
			"        }",
			"",
			"        void preorder() {",
			"            preorder(root);",
			"        }",
			"",
			"        void preorder(Node* root) {",
			"            if (root == nullptr) {",
			"                return;",
			"            }",
			"            cout << root->data << \" \";",
			"            preorder(root->left);",
			"            preorder(root->right);",
			"        }",
			"",
			"        void postorder() {",
			"            postorder(root);",
			"        }",
			"",
			"        void postorder(Node* root) {",
			"            if (root == nullptr) {",
			"                return;",
			"            }",
			"            postorder(root->left);",
			"            postorder(root->right);",
			"            cout << root->data << \" \";",
			"        }",
			"",
			"        Node* findMin(Node* node) {",
			"            Node* current = node;",
			"            while (current && current->left != nullptr) {",
			"                current = current->left;",
			"            }",
			"            return current;",
			"        }",
			"",
			"        Node* findMax(Node* node) {",
			"            Node* current = node;",
			"            while (current && current->right != nullptr) {",
			"                current = current->right;",
			"            }",
			"            return current;",
			"        }",
			"",
			"        Node* deleteNode(Node* root, int key) {",
			"            if (root == nullptr) {",
			"                return root;",
			"            }",
			"",
			"            if (key < root->data) {",
			"                root->left = deleteNode(root->left, key);",
			"            } else if (key > root->data) {",
			"                root->right = deleteNode(root->right, key);",
			"            } else {",
			"                if (root->left == nullptr && root->right == nullptr) {",
			"                    delete root;",
			"                    return nullptr;",
			"                } else if (root->left == nullptr) {",
			"                    Node* temp = root->right;",
			"                    delete root;",
			"                    return temp;",
			"                } else if (root->right == nullptr) {",
			"                    Node* temp = root->left;",
			"                    delete root;",
			"                    return temp;",
			"                }",
			"",
			"                Node* temp = findMin(root->right);",
			"                root->data = temp->data;",
			"                root->right = deleteNode(root->right, temp->data);",
			"            }",
			"            return root;",
			"        }",
			"",
			"        void deleteValue(int key) {",
			"            root = deleteNode(root, key);",
			"        }",
			"}",
			"};"
		],
		"description": "Binary Search Tree implementation with insert, delete, traversal, and utility functions."
	},
	"Product and Tree with Search, Insert, Update, and Traversals": {
		"scope": "cpp",
		"prefix": "producttree",
		"body": [
			"class Product {",
			"public:",
			"    int id;",
			"    int stock;",
			"    Product(int i = -1, int s = 0) : id(i), stock(s) {}",
			"};",
			"",
			"class Node {",
			"public:",
			"    Product data;",
			"    Node* left;",
			"    Node* right;",
			"    Node(Product d) : data(d), left(nullptr), right(nullptr) {}",
			"};",
			"",
			"class Tree {",
			"    Node* root;",
			"",
			"public:",
			"    Tree() : root(nullptr) {}",
			"",
			"    Node* getroot() {",
			"        return root;",
			"    }",
			"",
			"    void insert(Product val) {",
			"        Node* new_node = new Node(val);",
			"        if (root == nullptr) {",
			"            root = new_node;",
			"            return;",
			"        }",
			"        Node* curr = root;",
			"        Node* par = nullptr;",
			"",
			"        while (curr != nullptr) {",
			"            par = curr;",
			"            if (val.stock < curr->data.stock) {",
			"                curr = curr->left;",
			"            } else {",
			"                curr = curr->right;",
			"            }",
			"        }",
			"",
			"        if (val.stock < par->data.stock) {",
			"            par->left = new_node;",
			"        } else {",
			"            par->right = new_node;",
			"        }",
			"    }",
			"",
			"    bool updatequantity(int id, int new_stock) {",
			"        Node* curr = root;",
			"        while (curr != nullptr) {",
			"            if (curr->data.id == id) {",
			"                curr->data.stock = new_stock;",
			"                return true;",
			"            } else if (id < curr->data.id) {",
			"                curr = curr->left;",
			"            } else {",
			"                curr = curr->right;",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"",
			"    bool searchproduct(int id, int& stock) {",
			"        Node* curr = root;",
			"        while (curr != nullptr) {",
			"            if (curr->data.id == id) {",
			"                stock = curr->data.stock;",
			"                return true;",
			"            } else if (id < curr->data.id) {",
			"                curr = curr->left;",
			"            } else {",
			"                curr = curr->right;",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"",
			"    Product getproductwithhigheststock() {",
			"        if (root == nullptr) {",
			"            return Product();",
			"        }",
			"",
			"        Node* curr = root;",
			"        while (curr->right != nullptr) {",
			"            curr = curr->right;",
			"        }",
			"        return curr->data;",
			"    }",
			"",
			"    void inorder() {",
			"        inorder(root);",
			"    }",
			"",
			"    void inorder(Node* root) {",
			"        if (root == nullptr) {",
			"            return;",
			"        }",
			"        inorder(root->left);",
			"        cout << \"ID: \" << root->data.id << \", Stock: \" << root->data.stock << endl;",
			"        inorder(root->right);",
			"    }",
			"};"
		],
		"description": "Class implementation for Product and Binary Search Tree (BST) to manage products with stock levels and provide insert, update, search, and traversal functionalities."
	},
	"Find Median in Binary Search Tree": {
		"scope": "cpp",
		"prefix": "findmedianBST",
		"body": [
			"void find_median() {",
			"    int total_nodes = 0;",
			"    total_nodes = count_nodes(root);",
			"",
			"    if (total_nodes == 0) {",
			"        cout << \"Tree is empty.\" << endl;",
			"        return;",
			"    }",
			"",
			"    int median_position = (total_nodes % 2 == 0) ? (total_nodes / 2) : (total_nodes / 2 + 1);",
			"    int current_count = 0;",
			"    int median_value = 0;",
			"",
			"    find_median_util(root, median_position, current_count, median_value);",
			"",
			"    if (total_nodes % 2 == 0) {",
			"        int next_value = 0;",
			"        find_median_util(root, median_position + 1, current_count, next_value);",
			"        median_value = (median_value + next_value) / 2.0;",
			"        cout << \"Median: \" << median_value << endl;",
			"    } else {",
			"        cout << \"Median: \" << median_value << endl;",
			"    }",
			"}",
			"",
			"void find_median_util(Node* node, int k, int& current_count, int& median_value) {",
			"    if (node == nullptr) {",
			"        return;",
			"    }",
			"",
			"    find_median_util(node->left, k, current_count, median_value);",
			"",
			"    current_count++;",
			"    if (current_count == k) {",
			"        median_value = node->data;",
			"        return;",
			"    }",
			"",
			"    find_median_util(node->right, k, current_count, median_value);",
			"}",
			"",
			"int count_nodes(Node* node) {",
			"    if (node == nullptr) {",
			"        return 0;",
			"    }",
			"    return 1 + count_nodes(node->left) + count_nodes(node->right);",
			"}"
		],
		"description": "Function to find the median of a Binary Search Tree (BST)."
	},
	"Count Nodes in Range in Binary Search Tree": {
		"scope": "cpp",
		"prefix": "countnodesinrangeBST",
		"body": [
			"int count_nodes_in_range(Node* node, int a, int b) {",
			"    if (node == nullptr) {",
			"        return 0;",
			"    }",
			"",
			"    if (node->data >= a && node->data <= b) {",
			"        return 1 + count_nodes_in_range(node->left, a, b) + count_nodes_in_range(node->right, a, b);",
			"    }",
			"",
			"    if (node->data < a) {",
			"        return count_nodes_in_range(node->right, a, b);",
			"    }",
			"",
			"    return count_nodes_in_range(node->left, a, b);",
			"}",
			"",
			"int count_nodes_in_range(int a, int b) {",
			"    return count_nodes_in_range(root, a, b);",
			"}"
		],
		"description": "Function to count the number of nodes in a Binary Search Tree (BST) within a given range [a, b]."
	},
	"AVL Tree Functions": {
		"scope": "cpp",
		"prefix": "avlfunctions",
		"body": [
			"class TreeNode {",
			"public:",
			"    int val;",
			"    TreeNode* rightChild;",
			"    TreeNode* leftChild;",
			"    int nodeHeight;",
			"",
			"    TreeNode(int value) : val(value), rightChild(nullptr), leftChild(nullptr), nodeHeight(1) {}",
			"};",
			"",
			"int findHeight(TreeNode* node) {",
			"    if (node == nullptr) return 0;",
			"    return node->nodeHeight;",
			"}",
			"",
			"int balanceFactor(TreeNode* node) {",
			"    return findHeight(node->leftChild) - findHeight(node->rightChild);",
			"}",
			"",
			"TreeNode* rotateRight(TreeNode* node) {",
			"    TreeNode* temp = node->leftChild;",
			"    TreeNode* tempRight = temp->rightChild;",
			"",
			"    temp->rightChild = node;",
			"    node->leftChild = tempRight;",
			"",
			"    node->nodeHeight = 1 + max(findHeight(node->leftChild), findHeight(node->rightChild));",
			"    temp->nodeHeight = 1 + max(findHeight(temp->leftChild), findHeight(temp->rightChild));",
			"",
			"    return temp;",
			"}",
			"",
			"TreeNode* rotateLeft(TreeNode* node) {",
			"    TreeNode* temp = node->rightChild;",
			"    TreeNode* tempLeft = temp->leftChild;",
			"",
			"    temp->leftChild = node;",
			"    node->rightChild = tempLeft;",
			"",
			"    node->nodeHeight = 1 + max(findHeight(node->leftChild), findHeight(node->rightChild));",
			"    temp->nodeHeight = 1 + max(findHeight(temp->leftChild), findHeight(temp->rightChild));",
			"",
			"    return temp;",
			"}",
			"",
			"TreeNode* convertToAVL(TreeNode* node) {",
			"    if (node == nullptr) return node;",
			"",
			"    int balance = balanceFactor(node);",
			"",
			"    if (balance > 1) {",
			"        if (balanceFactor(node->leftChild) >= 0) {",
			"            return rotateRight(node);",
			"        } else {",
			"            node->leftChild = rotateLeft(node->leftChild);",
			"            return rotateRight(node);",
			"        }",
			"    } else if (balance < -1) {",
			"        if (balanceFactor(node->rightChild) <= 0) {",
			"            return rotateLeft(node);",
			"        } else {",
			"            node->rightChild = rotateRight(node->rightChild);",
			"            return rotateLeft(node);",
			"        }",
			"    }",
			"",
			"    return node;",
			"}",
			"",
			"TreeNode* insertNode(TreeNode* node, int value) {",
			"    if (node == nullptr) return new TreeNode(value);",
			"",
			"    if (value < node->val) {",
			"        node->leftChild = insertNode(node->leftChild, value);",
			"    } else if (value > node->val) {",
			"        node->rightChild = insertNode(node->rightChild, value);",
			"    }",
			"",
			"    node->nodeHeight = 1 + max(findHeight(node->leftChild), findHeight(node->rightChild));",
			"",
			"    return node;",
			"}",
			"",
			"void preorderTraversal(TreeNode* node) {",
			"    if (node == nullptr) return;",
			"",
			"    cout << node->val << ' ';",
			"    preorderTraversal(node->leftChild);",
			"    preorderTraversal(node->rightChild);",
			"}"
		],
		"description": "Functions for AVL Tree operations including rotation, insertion, and balancing."
	},
	"AVL Tree Implementation": {
		"scope": "cpp",
		"prefix": "avltree_student",
		"body": [
			"class Student {",
			"public:",
			"    string studentName;",
			"    int studentID;",
			"    int studentRoll;",
			"",
			"    Student(): studentName(\"\"), studentID(0), studentRoll(0) {}",
			"    Student(string n, int id, int roll): studentName(n), studentID(id), studentRoll(roll) {}",
			"};",
			"",
			"class TreeNode {",
			"public:",
			"    Student* record;",
			"    TreeNode* rightChild;",
			"    TreeNode* leftChild;",
			"    int nodeHeight;",
			"",
			"    TreeNode(Student* s): record(s), rightChild(nullptr), leftChild(nullptr), nodeHeight(1) {}",
			"};",
			"",
			"int findHeight(TreeNode* node) {",
			"    return node ? node->nodeHeight : 0;",
			"}",
			"",
			"int balanceFactor(TreeNode* node) {",
			"    return node ? findHeight(node->leftChild) - findHeight(node->rightChild) : 0;",
			"}",
			"",
			"int maxVal(int a, int b) {",
			"    return (a > b) ? a : b;",
			"}",
			"",
			"TreeNode* rotateRight(TreeNode* node) {",
			"    TreeNode* temp = node->leftChild;",
			"    TreeNode* tempRight = temp->rightChild;",
			"",
			"    temp->rightChild = node;",
			"    node->leftChild = tempRight;",
			"",
			"    node->nodeHeight = 1 + maxVal(findHeight(node->leftChild), findHeight(node->rightChild));",
			"    temp->nodeHeight = 1 + maxVal(findHeight(temp->leftChild), findHeight(temp->rightChild));",
			"",
			"    return temp;",
			"}",
			"",
			"TreeNode* rotateLeft(TreeNode* node) {",
			"    TreeNode* temp = node->rightChild;",
			"    TreeNode* tempLeft = temp->leftChild;",
			"",
			"    temp->leftChild = node;",
			"    node->rightChild = tempLeft;",
			"",
			"    node->nodeHeight = 1 + maxVal(findHeight(node->leftChild), findHeight(node->rightChild));",
			"    temp->nodeHeight = 1 + maxVal(findHeight(temp->leftChild), findHeight(temp->rightChild));",
			"",
			"    return temp;",
			"}",
			"",
			"TreeNode* insertNode(TreeNode* node, Student* s) {",
			"    if (node == nullptr) {",
			"        return new TreeNode(s);",
			"    }",
			"",
			"    if (s->studentRoll < node->record->studentRoll) {",
			"        node->leftChild = insertNode(node->leftChild, s);",
			"    } else if (s->studentRoll > node->record->studentRoll) {",
			"        node->rightChild = insertNode(node->rightChild, s);",
			"    } else {",
			"        return node;",
			"    }",
			"",
			"    node->nodeHeight = 1 + maxVal(findHeight(node->leftChild), findHeight(node->rightChild));",
			"",
			"    int balance = balanceFactor(node);",
			"",
			"    if (balance > 1 && s->studentRoll < node->leftChild->record->studentRoll) {",
			"        return rotateRight(node);",
			"    }",
			"    if (balance < -1 && s->studentRoll > node->rightChild->record->studentRoll) {",
			"        return rotateLeft(node);",
			"    }",
			"    if (balance > 1 && s->studentRoll > node->leftChild->record->studentRoll) {",
			"        node->leftChild = rotateLeft(node->leftChild);",
			"        return rotateRight(node);",
			"    }",
			"    if (balance < -1 && s->studentRoll < node->rightChild->record->studentRoll) {",
			"        node->rightChild = rotateRight(node->rightChild);",
			"        return rotateLeft(node);",
			"    }",
			"",
			"    return node;",
			"}",
			"",
			"void inOrderTraversal(TreeNode* node) {",
			"    if (node != nullptr) {",
			"        inOrderTraversal(node->leftChild);",
			"        cout << \"Name: \" << node->record->studentName << \", ID: \" << node->record->studentID ",
			"             << \", RollNo: \" << node->record->studentRoll << endl;",
			"        inOrderTraversal(node->rightChild);",
			"    }",
			"}"
		],
		"description": "Complete implementation of an AVL Tree with Student records, including node insertion and in-order traversal."
	},
	"Kth Element in BST": {
		"scope": "cpp",
		"prefix": "kthbst",
		"body": [
			"int findKthSmallest(TreeNode* node, int k) {",
			"    if (!node || k < 1 || k > node->subTreeSize) return -1;",
			"",
			"    int leftSize = getSubTreeSize(node->leftChild);",
			"",
			"    if (k <= leftSize) {",
			"        return findKthSmallest(node->leftChild, k);",
			"    } else if (k == leftSize + 1) {",
			"        return node->value;",
			"    } else {",
			"        return findKthSmallest(node->rightChild, k - leftSize - 1);",
			"    }",
			"}",
			"",
			"int findKthLargest(TreeNode* node, int k) {",
			"    if (!node || k < 1 || k > node->subTreeSize) return -1;",
			"",
			"    int rightSize = getSubTreeSize(node->rightChild);",
			"",
			"    if (k <= rightSize) {",
			"        return findKthLargest(node->rightChild, k);",
			"    } else if (k == rightSize + 1) {",
			"        return node->value;",
			"    } else {",
			"        return findKthLargest(node->leftChild, k - rightSize - 1);",
			"    }",
			"}"
		],
		"description": "Functions to find the k-th smallest or largest element in a BST using subtree size tracking."
	},
	"MaxHeap Class": {
		"scope": "cpp",
		"prefix": "class_maxheap",
		"body": [
			"#include <iostream>",
			"using namespace std;",
			"",
			"class MaxHeap {",
			"private:",
			"    int* heap;",
			"    int capacity;",
			"    int currentSize;",
			"",
			"    void swap(int& x, int& y) {",
			"        int temp = x;",
			"        x = y;",
			"        y = temp;",
			"    }",
			"",
			"    void heapify(int i) {",
			"        int largest = i;",
			"        int left = 2 * i + 1;",
			"        int right = 2 * i + 2;",
			"",
			"        if (left < currentSize && heap[left] > heap[largest])",
			"            largest = left;",
			"",
			"        if (right < currentSize && heap[right] > heap[largest])",
			"            largest = right;",
			"",
			"        if (largest != i) {",
			"            swap(heap[i], heap[largest]);",
			"            heapify(largest);",
			"        }",
			"    }",
			"",
			"public:",
			"    MaxHeap(int cap) {",
			"        capacity = cap;",
			"        heap = new int[capacity];",
			"        currentSize = 0;",
			"    }",
			"",
			"    void insert(int value) {",
			"        if (currentSize == capacity) {",
			"            cout << \"Heap is full!\" << endl;",
			"            return;",
			"        }",
			"",
			"        heap[currentSize] = value;",
			"        int i = currentSize;",
			"        currentSize++;",
			"",
			"        while (i > 0 && heap[(i - 1) / 2] < heap[i]) {",
			"            swap(heap[i], heap[(i - 1) / 2]);",
			"            i = (i - 1) / 2;",
			"        }",
			"    }",
			"",
			"    int deleteMax() {",
			"        if (currentSize <= 0) {",
			"            cout << \"Heap is empty!\" << endl;",
			"            return -1;",
			"        }",
			"",
			"        int root = heap[0];",
			"        heap[0] = heap[currentSize - 1];",
			"        currentSize--;",
			"",
			"        heapify(0);",
			"",
			"        return root;",
			"    }",
			"",
			"    int peek() const {",
			"        if (currentSize <= 0) {",
			"            cout << \"Heap is empty!\" << endl;",
			"            return -1;",
			"        }",
			"        return heap[0];",
			"    }",
			"",
			"    int extractMax() {",
			"        return deleteMax(); ",
			"    }",
			"",
			"    void buildHeap(int arr[], int n) {",
			"        if (n > capacity) {",
			"            cout << \"Array size exceeds heap capacity!\" << endl;",
			"            return;",
			"        }",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            heap[i] = arr[i];",
			"        }",
			"        currentSize = n;",
			"",
			"        for (int i = currentSize / 2 - 1; i >= 0; i--) {",
			"            heapify(i);",
			"        }",
			"    }",
			"",
			"    void printHeap() const {",
			"        for (int i = 0; i < currentSize; i++) {",
			"            cout << heap[i] << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"",
			"    int size() const {",
			"        return currentSize;",
			"    }",
			"",
			"    bool isEmpty() const {",
			"        return currentSize == 0;",
			"    }",
			"};",
			"",
			"int main() {",
			"    int capacity = 20; // define the max capacity for heap.",
			"    MaxHeap h(capacity);",
			"",
			"    h.insert(10);",
			"    h.insert(20);",
			"    h.insert(30);",
			"    h.insert(5);",
			"    h.insert(15);",
			"",
			"    cout << \"Heap: \";",
			"    h.printHeap();",
			"",
			"    cout << \"Peek (Max): \" << h.peek() << endl;",
			"",
			"    cout << \"Extracted Max: \" << h.extractMax() << endl;",
			"    cout << \"Heap after extraction: \";",
			"    h.printHeap();",
			"",
			"    int arr[] = {8, 2, 5, 3, 7, 10};",
			"    int arrSize = sizeof(arr) / sizeof(arr[0]);",
			"    h.buildHeap(arr, arrSize);",
			"    cout << \"Heap built from array: \";",
			"    h.printHeap();",
			"",
			"    return 0;",
			"}"
		],
		"description": "A MaxHeap implementation with various operations such as insertion, deletion, building a heap, and printing."
	},
	"MinHeap Class": {
		"scope": "cpp",
		"prefix": "minheap",
		"body": [
			"#include <iostream>",
			"using namespace std;",
			"",
			"class MinHeap {",
			"private:",
			"    int* heap;",
			"    int capacity;",
			"    int currentSize;",
			"",
			"    void swap(int& x, int& y) {",
			"        int temp = x;",
			"        x = y;",
			"        y = temp;",
			"    }",
			"",
			"    void heapify(int i) {",
			"        int smallest = i;",
			"        int left = 2 * i + 1;",
			"        int right = 2 * i + 2;",
			"",
			"        if (left < currentSize && heap[left] < heap[smallest])",
			"            smallest = left;",
			"",
			"        if (right < currentSize && heap[right] < heap[smallest])",
			"            smallest = right;",
			"",
			"        if (smallest != i) {",
			"            swap(heap[i], heap[smallest]);",
			"            heapify(smallest);",
			"        }",
			"    }",
			"",
			"public:",
			"    MinHeap(int cap) {",
			"        capacity = cap;",
			"        heap = new int[capacity];",
			"        currentSize = 0;",
			"    }",
			"",
			"    void insert(int value) {",
			"        if (currentSize == capacity) {",
			"            cout << \"Heap is full!\" << endl;",
			"            return;",
			"        }",
			"",
			"        heap[currentSize] = value;",
			"        int i = currentSize;",
			"        currentSize++;",
			"",
			"        while (i > 0 && heap[(i - 1) / 2] > heap[i]) {",
			"            swap(heap[i], heap[(i - 1) / 2]);",
			"            i = (i - 1) / 2;",
			"        }",
			"    }",
			"",
			"    int deleteMin() {",
			"        if (currentSize <= 0) {",
			"            cout << \"Heap is empty!\" << endl;",
			"            return -1;",
			"        }",
			"",
			"        int root = heap[0];",
			"        heap[0] = heap[currentSize - 1];",
			"        currentSize--;",
			"",
			"        heapify(0);",
			"",
			"        return root;",
			"    }",
			"",
			"    int peek() const {",
			"        if (currentSize <= 0) {",
			"            cout << \"Heap is empty!\" << endl;",
			"            return -1;",
			"        }",
			"        return heap[0];",
			"    }",
			"",
			"    int extractMin() {",
			"        return deleteMin();",
			"    }",
			"",
			"    void buildHeap(int arr[], int n) {",
			"        if (n > capacity) {",
			"            cout << \"Array size exceeds heap capacity!\" << endl;",
			"            return;",
			"        }",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            heap[i] = arr[i];",
			"        }",
			"        currentSize = n;",
			"",
			"        for (int i = currentSize / 2 - 1; i >= 0; i--) {",
			"            heapify(i);",
			"        }",
			"    }",
			"",
			"    void printHeap() const {",
			"        for (int i = 0; i < currentSize; i++) {",
			"            cout << heap[i] << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"",
			"    int size() const {",
			"        return currentSize;",
			"    }",
			"",
			"    bool isEmpty() const {",
			"        return currentSize == 0;",
			"    }",
			"};",
			"",
			"int main() {",
			"    int capacity = 20; // define the max capacity for heap",
			"    MinHeap h(capacity);",
			"",
			"    h.insert(10);",
			"    h.insert(20);",
			"    h.insert(30);",
			"    h.insert(5);",
			"    h.insert(15);",
			"",
			"    cout << \"Heap: \";",
			"    h.printHeap();",
			"",
			"    cout << \"Peek (Min): \" << h.peek() << endl;",
			"",
			"    cout << \"Extracted Min: \" << h.extractMin() << endl;",
			"    cout << \"Heap after extraction: \";",
			"    h.printHeap();",
			"",
			"    int arr[] = {8, 2, 5, 3, 7, 10};",
			"    int arrSize = sizeof(arr) / sizeof(arr[0]);",
			"    h.buildHeap(arr, arrSize);",
			"    cout << \"Heap built from array: \";",
			"    h.printHeap();",
			"",
			"    return 0;",
			"}"
		],
		"description": "A MinHeap implementation with various operations such as insertion, deletion, building a heap, and printing."
	},
	"Node and MaxHeap Class": {
    "scope": "cpp",
    "prefix": "maxheap",
    "body": [
        "class Node {",
        "public:",
        "    int data;",
        "    Node(int value) {",
        "        data = value;",
        "    }",
        "};",
        "",
        "void swap(Node*& a, Node*& b) {",
        "    Node* temp = a;",
        "    a = b;",
        "    b = temp;",
        "}",
        "",
        "class MaxHeap {",
        "    Node* heap[100];",
        "    int size;",
        "",
        "    void heapify(int i) {",
        "        int largest = i;",
        "        int left = 2 * i + 1;",
        "        int right = 2 * i + 2;",
        "",
        "        if (left < size && heap[left]->data > heap[largest]->data)",
        "            largest = left;",
        "",
        "        if (right < size && heap[right]->data > heap[largest]->data)",
        "            largest = right;",
        "",
        "        if (largest != i) {",
        "            swap(heap[i], heap[largest]);",
        "            heapify(largest);",
        "        }",
        "    }",
        "",
        "public:",
        "    MaxHeap() : size(0) {}",
        "",
        "    void insert(int value) {",
        "        heap[size] = new Node(value);",
        "        int i = size;",
        "        size++;",
        "",
        "        while (i > 0 && heap[(i - 1) / 2]->data < heap[i]->data) {",
        "            swap(heap[i], heap[(i - 1) / 2]);",
        "            i = (i - 1) / 2;",
        "        }",
        "    }",
        "",
        "    void removeRoot() {",
        "        if (size == 0) {",
        "            cout << \"Heap is empty!\" << endl;",
        "            return;",
        "        }",
        "        heap[0] = heap[size - 1];",
        "        size--;",
        "        heapify(0);",
        "    }",
        "",
        "    void display() {",
        "        for (int i = 0; i < size; i++) {",
        "            cout << heap[i]->data << \" \";",
        "        }",
        "        cout << endl;",
        "    }",
        "};"
    ],
    "description": "A MaxHeap implementation using an array of Node objects with basic operations like insertion, removal, and display."
},

	"Node and AVL Class": {
		"scope": "cpp",
		"prefix": "has_avl_class",
		"body": [
			"class Node {",
			"public:",
			"    int data;",
			"    Node *left;",
			"    Node *right;",
			"    int height;",
			"",
			"    Node(int data) {",
			"        this->data = data;",
			"        left = right = NULL;",
			"        height = 1;",
			"    }",
			"};",
			"",
			"class AVL {",
			"    Node *root;",
			"",
			"    void updateHeight(Node *node) {",
			"        node->height = 1 + max(node->left ? node->left->height : 0, node->right ? node->right->height : 0);",
			"    }",
			"",
			"    int balanceFactor(Node *node) {",
			"        int hl = node->left ? node->left->height : 0;",
			"        int hr = node->right ? node->right->height : 0;",
			"        return hl - hr;",
			"    }",
			"",
			"    Node* rightRotate(Node *root) {",
			"        Node *y = root->left;",
			"        Node *temp = y->right;",
			"        root->left = temp;",
			"        y->right = root;",
			"        updateHeight(root);",
			"        updateHeight(y);",
			"        return y;",
			"    }",
			"",
			"    Node* leftRotate(Node *root) {",
			"        Node *y = root->right;",
			"        Node *temp = y->left;",
			"        root->right = temp;",
			"        y->left = root;",
			"        updateHeight(root);",
			"        updateHeight(y);",
			"        return y;",
			"    }",
			"",
			"    Node* insert(Node* root, int d) {",
			"        if (root == NULL) {",
			"            return new Node(d);",
			"        }",
			"        if (d < root->data) {",
			"            root->left = insert(root->left, d);",
			"        } else if (d > root->data) {",
			"            root->right = insert(root->right, d);",
			"        }",
			"",
			"        updateHeight(root);",
			"",
			"        int bf = balanceFactor(root);",
			"",
			"        if (bf == -2 && balanceFactor(root->right) == -1) {",
			"            return leftRotate(root);",
			"        }",
			"        if (bf == 2 && balanceFactor(root->left) == 1) {",
			"            return rightRotate(root);",
			"        }",
			"        if (bf == -2 && balanceFactor(root->right) == 1) {",
			"            root->right = rightRotate(root->right);",
			"            return leftRotate(root);",
			"        }",
			"        if (bf == 2 && balanceFactor(root->left) == -1) {",
			"            root->left = leftRotate(root->left);",
			"            return rightRotate(root);",
			"        }",
			"",
			"        return root;",
			"    }",
			"",
			"public:",
			"    AVL() : root(NULL) {}",
			"",
			"    void insert(int data) {",
			"        root = insert(root, data);",
			"    }",
			"",
			"    Node* findMin(Node *root) {",
			"        while (root && root->left) root = root->left;",
			"        return root;",
			"    }",
			"",
			"    Node* deleteNode(Node* root, int value) {",
			"        if (root == NULL) {",
			"            return NULL;",
			"        }",
			"        if (value < root->data) {",
			"            root->left = deleteNode(root->left, value);",
			"        } else if (value > root->data) {",
			"            root->right = deleteNode(root->right, value);",
			"        } else {",
			"            if (root->left == NULL && root->right == NULL) {",
			"                delete root;",
			"                return NULL;",
			"            } else if (root->left == NULL) {",
			"                Node* temp = root->right;",
			"                delete root;",
			"                return temp;",
			"            } else if (root->right == NULL) {",
			"                Node* temp = root->left;",
			"                delete root;",
			"                return temp;",
			"            } else {",
			"                Node* temp = findMin(root->right);",
			"                root->data = temp->data;",
			"                root->right = deleteNode(root->right, temp->data);",
			"            }",
			"        }",
			"",
			"        updateHeight(root);",
			"",
			"        int bf = balanceFactor(root);",
			"",
			"        if (bf == -2 && balanceFactor(root->right) == -1) {",
			"            return leftRotate(root);",
			"        }",
			"        if (bf == 2 && balanceFactor(root->left) == 1) {",
			"            return rightRotate(root);",
			"        }",
			"        if (bf == -2 && balanceFactor(root->right) == 1) {",
			"            root->right = rightRotate(root->right);",
			"            return leftRotate(root);",
			"        }",
			"        if (bf == 2 && balanceFactor(root->left) == -1) {",
			"            root->left = leftRotate(root->left);",
			"            return rightRotate(root);",
			"        }",
			"",
			"        return root;",
			"    }",
			"",
			"    void deleteNode(int value) {",
			"        root = deleteNode(root, value);",
			"    }",
			"",
			"    void printTree(Node* root, string indent = \"\", bool isLeft = true) {",
			"        if (root != NULL) {",
			"            cout << indent;",
			"            if (isLeft) {",
			"                cout << \"L----\";",
			"                indent += \"     \";",
			"            } else {",
			"                cout << \"R----\";",
			"                indent += \"|    \";",
			"            }",
			"            cout << root->data << endl;",
			"            printTree(root->left, indent, true);",
			"            printTree(root->right, indent, false);",
			"        }",
			"    }",
			"",
			"    void printTree() {",
			"        printTree(root);",
			"    }",
			"",
			"    void inorder(Node* root, int& sum) {",
			"        if (root != NULL) {",
			"            inorder(root->left, sum);",
			"            cout << root->data << \" \";",
			"            sum += root->data;",
			"            inorder(root->right, sum);",
			"        }",
			"    }",
			"",
			"    void inorder() {",
			"        int sum = 0;",
			"        inorder(root, sum);",
			"        cout << \"Sum of all nodes: \" << sum << endl;",
			"        cout << endl;",
			"    }",
			"",
			"    bool check_prime(int n) {",
			"        if (n <= 1) {",
			"            return false;",
			"        }",
			"        for (int i = 2; i * i <= n; i++) {",
			"            if (n % i == 0) {",
			"                return false;",
			"            }",
			"        }",
			"        return true;",
			"    }",
			"",
			"    int count_nodes_prime_only(Node* root, int& count) {",
			"        if (root == NULL) {",
			"            return 0;",
			"        }",
			"        if (check_prime(root->data)) {",
			"            count++;",
			"        }",
			"        count_nodes_prime_only(root->left, count);",
			"        count_nodes_prime_only(root->right, count);",
			"        return count;",
			"    }",
			"",
			"    int count_nodes_prime_only() {",
			"        int count = 0;",
			"        return count_nodes_prime_only(root, count);",
			"    }",
			"",
			"    void postorder(Node* root) {",
			"        if (root != NULL) {",
			"            postorder(root->left);",
			"            postorder(root->right);",
			"            cout << root->data << \" \";",
			"        }",
			"    }",
			"",
			"    void postorder() {",
			"        postorder(root);",
			"        cout << endl;",
			"    }",
			"",
			"    void preorder(Node* root) {",
			"        if (root != NULL) {",
			"            cout << root->data << \" \";",
			"            preorder(root->left);",
			"            preorder(root->right);",
			"        }",
			"    }",
			"",
			"    void preorder() {",
			"        preorder(root);",
			"        cout << endl;",
			"    }",
			"",
			"    void level_order(Node *root) {",
			"        if (root == NULL) {",
			"            return;",
			"        }",
			"        queue<Node *> q;",
			"        q.push(root);",
			"        while (!q.empty()) {",
			"            Node *temp = q.front();",
			"            q.pop();",
			"            cout << temp->data << \" \";",
			"            if (temp->left != NULL) {",
			"                q.push(temp->left);",
			"            }",
			"            if (temp->right != NULL) {",
			"                q.push(temp->right);",
			"            }",
			"        }",
			"    }",
			"",
			"    void level_order() {",
			"        level_order(root);",
			"        cout << endl;",
			"    }",
			"",
			"    void search_parent(Node* root, int val, Node* &parent) {",
			"        if (root == NULL) {",
			"            return;",
			"        }",
			"        if (val < root->data) {",
			"            parent = root;",
			"            search_parent(root->left, val, parent);",
			"        }",
			"        else if (val > root->data) {",
			"            parent = root;",
			"            search_parent(root->right, val, parent);",
			"        }",
			"    }",
			"",
			"    void search_closest(int val) {",
			"        this->insert(val);",
			"        Node* parent = NULL;",
			"        search_parent(root, val, parent);",
			"        this->deleteNode(val);",
			"        cout << \"Closest value of \" << val << \" is: \" << parent->data << endl;",
			"    }",
			"",
			"    int count_nodes(Node *root) {",
			"        if (root == NULL) {",
			"            return 0;",
			"        }",
			"        return 1 + count_nodes(root->left) + count_nodes(root->right);",
			"    }",
			"",
			"    int count_nodes() {",
			"        return count_nodes(root);",
			"    }",
			"",
			"    bool check_CBT(Node *root, int index) {",
			"        if (root == NULL) {",
			"            return true;",
			"        }",
			"        if (index >= count_nodes(root)) {",
			"            return false;",
			"        }",
			"        return check_CBT(root->left, 2 * index + 1) && check_CBT(root->right, 2 * index + 2);",
			"    }",
			"",
			"    bool check_CBT() {",
			"        return check_CBT(root, 0);",
			"    }",
			"",
			"    void find_all_paths(Node *root, vector<int> &path, vector<vector<int>> &paths) {",
			"        if (root == NULL) {",
			"            return;",
			"        }",
			"        path.push_back(root->data);",
			"        if (root->left == NULL && root->right == NULL) {",
			"            paths.push_back(path);",
			"        }",
			"        find_all_paths(root->left, path, paths);",
			"        find_all_paths(root->right, path, paths);",
			"        path.pop_back();",
			"    }",
			"",
			"    void find_all_paths() {",
			"        vector<int> path;",
			"        vector<vector<int>> paths;",
			"        find_all_paths(root, path, paths);",
			"        for (auto v : paths) {",
			"            for (auto i : v) {",
			"                cout << i << \" \";",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"};"
		]
	},

    "has_BST_Class_Implementation": {
    "scope": "cpp",
    "prefix": "has_bst_class",
    "body": [
        "vector<int> v; // Global vector to store for mirror",
        "",
        "template <class T>",
        "class Node {",
        "public:",
        "    T data;",
        "    Node *left, *right;",
        "",
        "    Node(T data) {",
        "        this->data = data;",
        "        left = right = NULL;",
        "    }",
        "};",
        "",
        "template <class T>",
        "class BST {",
        "    Node<T> *root;",
        "",
        "public:",
        "    BST() {",
        "        root = NULL;",
        "    }",
        "",
        "    Node<T> *insertrecur(Node<T> *root1, T val) {",
        "        if (root1 == NULL) {",
        "            return new Node<T>(val);",
        "        }",
        "        if (val < root1->data) {",
        "            root1->left = insertrecur(root1->left, val);",
        "        } else {",
        "            root1->right = insertrecur(root1->right, val);",
        "        }",
        "        return root1;",
        "    }",
        "",
        "    void insertrecur(T val) {",
        "        root = insertrecur(root, val);",
        "    }",
        "",
        "    void insert_Refer(Node<T> *&rootRef, T val) {",
        "        if (rootRef == NULL) {",
        "            rootRef = new Node<T>(val);",
        "            return;",
        "        }",
        "        if (val < rootRef->data) {",
        "            insert_Refer(rootRef->left, val);",
        "        } else {",
        "            insert_Refer(rootRef->right, val);",
        "        }",
        "    }",
        "",
        "    void insert_Refer(T val) {",
        "        insert_Refer(root, val);",
        "    }",
        "",
        "    void insert_iterative(T val) {",
        "        if (root == NULL) {",
        "            root = new Node<T>(val);",
        "            return;",
        "        }",
        "        Node<T> *temp = root;",
        "        Node<T> *prev = NULL;",
        "        while (temp) {",
        "            prev = temp;",
        "            if (val < temp->data) {",
        "                temp = temp->left;",
        "            } else {",
        "                temp = temp->right;",
        "            }",
        "        }",
        "        if (val < prev->data) {",
        "            prev->left = new Node<T>(val);",
        "        } else {",
        "            prev->right = new Node<T>(val);",
        "        }",
        "    }",
        "",
        "    bool search_iter(T val) {",
        "        Node<T> *temp = root;",
        "        while (temp) {",
        "            if (temp->data == val) {",
        "                return true;",
        "            } else if (val < temp->data) {",
        "                temp = temp->left;",
        "            } else {",
        "                temp = temp->right;",
        "            }",
        "        }",
        "        return false;",
        "    }",
        "",
        "    bool search_recur(Node<T> *root, T data) {",
        "        if (root == NULL) {",
        "            return false;",
        "        }",
        "        if (root->data == data) {",
        "            return true;",
        "        } else if (data < root->data) {",
        "            return search_recur(root->left, data);",
        "        } else {",
        "            return search_recur(root->right, data);",
        "        }",
        "    }",
        "",
        "    bool search_recur(T data) {",
        "        return search_recur(root, data);",
        "    }",
        "",
        "    Node<T> *findMin(Node<T> *root) {",
        "        while (root && root->left)",
        "            root = root->left;",
        "        return root;",
        "    }",
        "",
        "    Node<T> *deleteNode(Node<T> *root, T value) {",
        "        if (root == NULL) {",
        "            return NULL;",
        "        }",
        "        if (root->data > value) {",
        "            root->left = deleteNode(root->left, value);",
        "        } else if (root->data < value) {",
        "            root->right = deleteNode(root->right, value);",
        "        } else {",
        "            if (root->left == NULL && root->right == NULL) {",
        "                delete root;",
        "                return NULL;",
        "            } else if (root->left == NULL) {",
        "                Node<T> *temp = root->right;",
        "                delete root;",
        "                return temp;",
        "            } else if (root->right == NULL) {",
        "                Node<T> *temp = root->left;",
        "                delete root;",
        "                return temp;",
        "            } else {",
        "                Node<T> *temp = findMin(root->right);",
        "                root->data = temp->data;",
        "                root->right = deleteNode(root->right, temp->data);",
        "            }",
        "        }",
        "        return root;",
        "    }",
        "",
        "    void deleteNode(T value) {",
        "        root = deleteNode(root, value);",
        "    }",
        "",
        "    void inOrder(Node<T> *node) {",
        "        if (node == NULL)",
        "            return;",
        "        inOrder(node->left);",
        "        cout << node->data << \" \";",
        "        inOrder(node->right);",
        "    }",
        "",
        "    void printInOrder() {",
        "        inOrder(root);",
        "        cout << endl;",
        "    }",
        "};"
    ],
    "description": "A comprehensive BST class template implementation with various operations like insertion, deletion, search, and traversal."
},

"has_HashTable_array_HashNode_Class": {
    "scope": "cpp",
    "prefix": "has_array_hash_table",
    "body": [
        "#define Table_Size 10",
        "",
        "class HashNode {",
        "public:",
        "    pair<char, string> data;",
        "    HashNode *next;",
        "",
        "    HashNode(char key, string value) {",
        "        this->data = make_pair(key, value);",
        "        this->next = nullptr;",
        "    }",
        "};",
        "",
        "class HashTable {",
        "    HashNode* table[Table_Size];",
        "",
        "public:",
        "    HashTable() {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            table[i] = nullptr;",
        "        }",
        "    }",
        "",
        "    int HashFunction(char key) {",
        "        return key % Table_Size;",
        "    }",
        "",
        "    void insert(char key, string value) {",
        "        int hash = HashFunction(key);",
        "",
        "        if (table[hash] == nullptr) {",
        "            table[hash] = new HashNode(key, value);",
        "            return;",
        "        }",
        "",
        "        HashNode* temp = table[hash];",
        "        while (temp != nullptr) {",
        "            if (temp->data.first == key) {",
        "                temp->data.second = value;",
        "                return;",
        "            }",
        "            temp = temp->next;",
        "        }",
        "",
        "        HashNode* newNode = new HashNode(key, value);",
        "        newNode->next = table[hash];",
        "        table[hash] = newNode;",
        "    }",
        "",
        "    void display_table() const {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            HashNode* temp = table[i];",
        "            while (temp != nullptr) {",
        "                cout << temp->data.first << \" \" << temp->data.second << endl;",
        "                temp = temp->next;",
        "            }",
        "        }",
        "    }",
        "",
        "    void search(char key) {",
        "        int hash = HashFunction(key);",
        "        HashNode* temp = table[hash];",
        "        while (temp != nullptr) {",
        "            if (temp->data.first == key) {",
        "                cout << \"Key found: Value: \" << temp->data.second << endl;",
        "                return;",
        "            }",
        "            temp = temp->next;",
        "        }",
        "        cout << \"Key not found\" << endl;",
        "    }",
        "",
        "    void remove(char key) {",
        "        int hash = HashFunction(key);",
        "        HashNode* temp = table[hash];",
        "        HashNode* prev = nullptr;",
        "",
        "        while (temp != nullptr) {",
        "            if (temp->data.first == key) {",
        "                if (prev == nullptr) {",
        "                    table[hash] = temp->next;",
        "                } else {",
        "                    prev->next = temp->next;",
        "                }",
        "                delete temp;",
        "                cout << \"Key found and removed\" << endl;",
        "                return;",
        "            }",
        "            prev = temp;",
        "            temp = temp->next;",
        "        }",
        "        cout << \"Key not found for removal\" << endl;",
        "    }",
        "};"
    ],
    "description": "A HashTable implementation using separate chaining for collision handling, with basic operations like insertion, search, removal, and display."
},

"has_HashTable_list_with_HashNode_Class": {
    "scope": "cpp",
    "prefix": "has_list_hash_table",
    "body": [
        "#define Table_Size 10",
        "",
        "class HashNode {",
        "public:",
        "    pair<char, string> data;",
        "    HashNode *next;",
        "",
        "    HashNode(char key, string value) {",
        "        this->data = make_pair(key, value);",
        "        this->next = nullptr;",
        "    }",
        "};",
        "",
        "class HashTable {",
        "    list<HashNode *> table[Table_Size];",
        "",
        "public:",
        "    HashTable() {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            table[i].push_front(nullptr);",
        "        }",
        "    }",
        "",
        "    int HashFunction(char key) {",
        "        return key % Table_Size;",
        "    }",
        "",
        "    void insert(char key, string value) {",
        "        int hash = HashFunction(key);",
        "        HashNode *newNode = new HashNode(key, value);",
        "        HashNode *temp = table[hash].front();",
        "        if (temp == nullptr) {",
        "            table[hash].push_front(newNode);",
        "            return;",
        "        }",
        "",
        "        for (auto &node : table[hash]) {",
        "            if (node->data.first == key) {",
        "                node->data.second = value;",
        "                return;",
        "            }",
        "        }",
        "        table[hash].push_front(newNode);",
        "    }",
        "",
        "    void display_table() const {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            HashNode *temp = table[i].front();",
        "            while (temp != nullptr) {",
        "                cout << temp->data.first << \" \" << temp->data.second << endl;",
        "                temp = temp->next;",
        "            }",
        "        }",
        "    }",
        "",
        "    void search(char key) {",
        "        int hash = HashFunction(key);",
        "        HashNode *temp = table[hash].front();",
        "        while (temp != nullptr) {",
        "            if (temp->data.first == key) {",
        "                cout << \"Key found: Value: \" << temp->data.second << endl;",
        "                return;",
        "            }",
        "            temp = temp->next;",
        "        }",
        "        cout << \"Key not found\" << endl;",
        "    }",
        "",
        "    void remove(char key) {",
        "        int hash = HashFunction(key);",
        "        HashNode *temp = table[hash].front();",
        "        HashNode *prev = nullptr;",
        "",
        "        while (temp != nullptr) {",
        "            if (temp->data.first == key) {",
        "                if (prev == nullptr) {",
        "                    table[hash].pop_front();",
        "                } else {",
        "                    prev->next = temp->next;",
        "                }",
        "                delete temp;",
        "                cout << \"Key found and removed\" << endl;",
        "                return;",
        "            }",
        "            prev = temp;",
        "            temp = temp->next;",
        "        }",
        "        cout << \"Key not found for removal\" << endl;",
        "    }",
        "};"
    ],
    "description": "A HashTable implementation using chaining with linked lists for collision resolution, supporting insertion, search, display, and removal operations."
},

"has_Quadratic_StudentHashTable_Class": {
    "scope": "cpp",
    "prefix": "has_quadratic_student_hashtable",
    "body": [
        "#define Table_Size 15",
        "",
        "class StudentHashTable {",
        "    pair<pair<string, int>, string> *table;",
        "",
        "    int quadratic_probe(int i) {",
        "        return i * i;",
        "    }",
        "",
        "public:",
        "    StudentHashTable() {",
        "        table = new pair<pair<string, int>, string>[Table_Size];",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            table[i].first.first = \" \";  // key",
        "            table[i].first.second = -1;  // index of probe",
        "            table[i].second = \" \";",
        "        }",
        "    }",
        "",
        "    int HashFunction(string key) {",
        "        int k = 0;",
        "        for (int i = 0; i < key.length(); i++) {",
        "            k += key[i];",
        "        }",
        "        return k % Table_Size;",
        "    }",
        "",
        "    void insert_record(string key, string value) {",
        "        int hash = HashFunction(key);",
        "        if (table[hash].first.first == \" \") {",
        "            pair<string, int> p = make_pair(key, 0);",
        "            table[hash].first = p;",
        "            table[hash].second = value;",
        "            return;",
        "        } else if (table[hash].first.first == key) {",
        "            table[hash].second = value;  // update the value",
        "            return;",
        "        } else {",
        "            int i = 1;",
        "            while (table[(hash + quadratic_probe(i)) % Table_Size].first.first != \" \") {",
        "                i++;",
        "            }",
        "            pair<string, int> p = make_pair(key, i);",
        "            table[(hash + i) % Table_Size].first = p;",
        "            table[(hash + i) % Table_Size].second = value;",
        "        }",
        "    }",
        "",
        "    void search_record(string key) {",
        "        int index = -1;",
        "        int hash = HashFunction(key);",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            if (table[i].first.first == key) {",
        "                index = table[i].first.second;",
        "                break;",
        "            }",
        "        }",
        "        if (index == -1) {",
        "            cout << \"Record not found\" << endl;",
        "            return;",
        "        }",
        "        cout << \"The Name is \" << table[(hash + index) % Table_Size].second << endl;",
        "    }",
        "",
        "    void display_table() {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            if (table[i].first.first != \" \" && table[i].first.second != -1 && table[i].second != \" \") {",
        "                cout << \" Key: \" << table[i].first.first << \", Probe Index: \" << table[i].first.second << \", Value: \" << table[i].second << endl;",
        "            }",
        "        }",
        "    }",
        "};"
    ],
    "description": "A hash table implementation with quadratic probing and string-based key-value pair storage for student records."
},

    "has_Heap_Class_Implementation":{
    "scope": "cpp",
    "prefix": "has_heap_class",
    "body": [
        "vector<int> v; // Global vector to store deleted elements",
        "",
        "class Heap {",
        "public:",
        "    int* arr;",
        "    int size;",
        "",
        "    Heap() {",
        "        size = 100;",
        "        arr = new int[size];",
        "        size = 0; // Correct initial size",
        "    }",
        "",
        "    void insert(int data) {",
        "        arr[size] = data;",
        "        size++;",
        "        // Heapify up from the inserted position",
        "        heapify_up(arr, size, size - 1);",
        "    }",
        "",
        "    void Delete() {",
        "        if (size == 0) {",
        "            cout << \"Heap is empty. Cannot delete!\" << endl;",
        "            return;",
        "        }",
        "",
        "        // Replace root with last element and reduce heap size",
        "        int temp = arr[0];",
        "        arr[0] = arr[size - 1]; // Last element replaces root",
        "        arr[size - 1] = temp;",
        "        v.push_back(arr[size - 1]); // Store the max element",
        "        size--; ",
        "",
        "        // Heapify down from the root",
        "        heapify_max_heap(arr, size, 0);",
        "    }",
        "",
        "    void print() {",
        "        for (int i = 0; i < size; i++) {",
        "            cout << arr[i] << \" \";",
        "        }",
        "        cout << endl;",
        "    }",
        "",
        "    void heapify_up(int arr[], int n, int index) {",
        "        while (index > 0) {",
        "            int parent_idx = (index - 1) / 2; // Adjusted for 0-based indexing",
        "            if (arr[parent_idx] < arr[index]) {",
        "                swap(arr[parent_idx], arr[index]);",
        "                index = parent_idx;",
        "            } else {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "",
        "    void heapify_up(vector<int>& arr, int n, int index) {",
        "        while (index > 0) {",
        "            int parent_idx = (index - 1) / 2; // Adjusted for 0-based indexing",
        "            if (arr[parent_idx] > arr[index]) {",
        "                swap(arr[parent_idx], arr[index]);",
        "                index = parent_idx;",
        "            } else {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "",
        "    void heapify_max_heap(int arr[], int n, int index) {",
        "        int largest = index;",
        "        int left = 2 * index + 1;  // Left child for 0-based indexing",
        "        int right = 2 * index + 2; // Right child for 0-based indexing",
        "",
        "        if (left < n && arr[left] > arr[largest]) {",
        "            largest = left;",
        "        }",
        "        if (right < n && arr[right] > arr[largest]) {",
        "            largest = right;",
        "        }",
        "",
        "        if (largest != index) {",
        "            swap(arr[index], arr[largest]);",
        "            heapify_max_heap(arr, n, largest);",
        "        }",
        "    }",
        "",
        "    void heapify_max_heap(vector<int>& arr, int n, int index) {",
        "        int largest = index;",
        "        int left = 2 * index + 1;  // Left child for 0-based indexing",
        "        int right = 2 * index + 2; // Right child for 0-based indexing",
        "",
        "        if (left < n && arr[left] > arr[largest]) {",
        "            largest = left;",
        "        }",
        "        if (right < n && arr[right] > arr[largest]) {",
        "            largest = right;",
        "        }",
        "",
        "        if (largest != index) {",
        "            swap(arr[index], arr[largest]);",
        "            heapify_max_heap(arr, n, largest);",
        "        }",
        "    }",
        "",
        "    void heapify_min_heap(vector<int>& arr, int n, int index) {",
        "        int smallest = index;",
        "        int left = 2 * index + 1;",
        "        int right = 2 * index + 2;",
        "",
        "        if (left < n && arr[index] > arr[left]) {",
        "            smallest = left;",
        "        }",
        "        if (right < n && arr[smallest] > arr[right]) {",
        "            smallest = right;",
        "        }",
        "",
        "        if (smallest != index) {",
        "            swap(arr[index], arr[smallest]);",
        "            heapify_min_heap(arr, n, smallest);",
        "        }",
        "    }",
        "",
        "    int get_nodes() {",
        "        return size;",
        "    }",
        "",
        "    bool isCBT(int index) {",
        "        if (size == 0) {",
        "            return true;",
        "        }",
        "        if (index >= size) {",
        "            return false;",
        "        }",
        "        int left = 2 * index + 1;",
        "        int right = 2 * index + 2;",
        "        bool leftCheck = (left < size) ? isCBT(left) : true;",
        "        bool rightCheck = (right < size) ? isCBT(right) : true;",
        "        return leftCheck && rightCheck;",
        "    }",
        "",
        "    bool isMax_heap(int index) {",
        "        if (!isCBT(0)) {",
        "            return false;",
        "        }",
        "        int left, right;",
        "        for (int i = 0; i < size; ++i) {",
        "            left = 2 * i + 1;",
        "            right = 2 * i + 2;",
        "            if (left < size && arr[i] < arr[left]) {",
        "                return false;",
        "            }",
        "            if (right < size && arr[i] < arr[right]) {",
        "                return false;",
        "            }",
        "        }",
        "        return true;",
        "    }",
        "",
        "    void mirror_Heap(int index) {",
        "        int left = 2 * index + 1;",
        "        int right = 2 * index + 2;",
        "        int temp = arr[left];",
        "        arr[left] = arr[right];",
        "        arr[right] = temp;",
        "        if (left < size) {",
        "            mirror_Heap(left);",
        "        }",
        "        if (right < size) {",
        "            mirror_Heap(right);",
        "        }",
        "    }",
        "};"
    ],
    "description": "A Heap implementation using an array, with methods for insertion, deletion, heapifying, and checking heap properties like max-heap and complete binary tree (CBT)."
},
    "Rating_freq_Hashtable" :{
    "scope": "cpp",
    "prefix": "has_rehash_mergesort_hash_table",
    "body": [
        "class HashNode {",
        "public:",
        "    int rating;",
        "    int frequency;",
        "    HashNode* next;",
        "",
        "    HashNode(int rating, int frequency) {",
        "        this->rating = rating;",
        "        this->frequency = frequency;",
        "        this->next = nullptr;",
        "    }",
        "",
        "    HashNode() {",
        "        this->rating = 0;",
        "        this->frequency = 0;",
        "        this->next = nullptr;",
        "    }",
        "};",
        "",
        "class HashTable {",
        "    HashNode** table;",
        "    int current_size;",
        "    int Table_Size;",
        "",
        "public:",
        "    HashTable() {",
        "        Table_Size = 5;",
        "        table = new HashNode*[Table_Size];",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            table[i] = nullptr;",
        "        }",
        "        current_size = 0;",
        "    }",
        "",
        "    int HashFunction(int key) {",
        "        return key % Table_Size;",
        "    }",
        "",
        "    void insert(int key) {",
        "        int hash = HashFunction(key);",
        "        current_size++;",
        "        if (table[hash] == nullptr) {",
        "            table[hash] = new HashNode(key, 1);",
        "            return;",
        "        }",
        "",
        "        HashNode* temp = table[hash];",
        "        while (temp->next != nullptr && temp->rating == key) {",
        "            temp = temp->next;",
        "        }",
        "        temp->next = new HashNode(key, 1);",
        "",
        "        if ((current_size / Table_Size) > 0.7)",
        "            rehash();",
        "    }",
        "",
        "    void rehash() {",
        "        int old_table_size = Table_Size;",
        "        HashNode** temp_table = table;",
        "",
        "        Table_Size = 2 * old_table_size;",
        "        table = new HashNode*[Table_Size];",
        "",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            table[i] = nullptr;",
        "        }",
        "",
        "        current_size = 0;",
        "",
        "        for (int i = 0; i < old_table_size; i++) {",
        "            HashNode* temp = temp_table[i];",
        "            while (temp != nullptr) {",
        "                insert(temp->rating);",
        "                temp = temp->next;",
        "            }",
        "        }",
        "    }",
        "",
        "    void display_table() const {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            cout << \"Bucket \" << i << \": \";",
        "            HashNode* temp = table[i];",
        "            while (temp != nullptr) {",
        "                cout << \"(\" << temp->rating << \", \" << temp->frequency << \") -> \";",
        "                temp = temp->next;",
        "            }",
        "            cout << \"nullptr\" << endl;",
        "        }",
        "    }",
        "",
        "    int get_size_of_HashNode(HashNode* temp) {",
        "        int count = 0;",
        "        while (temp != nullptr) {",
        "            count++;",
        "            temp = temp->next;",
        "        }",
        "        return count;",
        "    }",
        "",
        "    void for_sort(vector<pair<int, int>>& freq) {",
        "        int key;",
        "        int count = 0;",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            HashNode* temp = table[i];",
        "            if (temp != nullptr) {",
        "                key = temp->rating;",
        "                count = get_size_of_HashNode(temp);",
        "                freq.push_back(make_pair(key, count));",
        "            }",
        "        }",
        "    }",
        "};",
        "",
        "void merge(vector<pair<int, int>>& arr, int left, int mid, int right) {",
        "    int n1 = mid - left + 1;",
        "    int n2 = right - mid;",
        "    vector<pair<int, int>> leftArr(n1), rightArr(n2);",
        "",
        "    for (int i = 0; i < n1; i++)",
        "        leftArr[i] = arr[left + i];",
        "    for (int i = 0; i < n2; i++)",
        "        rightArr[i] = arr[mid + 1 + i];",
        "",
        "    int i = 0, j = 0, k = left;",
        "    while (i < n1 && j < n2) {",
        "        if (leftArr[i].second > rightArr[j].second) {",
        "            arr[k++] = leftArr[i++];",
        "        }",
        "        if (leftArr[i].second == rightArr[j].second) {",
        "            if (leftArr[i].first > rightArr[j].first) {",
        "                arr[k++] = leftArr[i++];",
        "            } else {",
        "                arr[k++] = rightArr[j++];",
        "            }",
        "        } else {",
        "            arr[k++] = rightArr[j++];",
        "        }",
        "    }",
        "",
        "    while (i < n1) {",
        "        arr[k++] = leftArr[i++];",
        "    }",
        "    while (j < n2) {",
        "        arr[k++] = rightArr[j++];",
        "    }",
        "}",
        "",
        "void mergeSort(vector<pair<int, int>>& arr, int left, int right) {",
        "    if (left < right) {",
        "        int mid = left + (right - left) / 2;",
        "        mergeSort(arr, left, mid);",
        "        mergeSort(arr, mid + 1, right);",
        "        merge(arr, left, mid, right);",
        "    }",
        "}"
    ],
    "description": "A HashTable implementation with chaining using HashNodes, featuring operations like insertion, rehashing, sorting by frequency, and displaying the table."
},

"Key_Value_DoubleHashing_Hashtable": {
    "scope": "cpp",
    "prefix": "has_double_hashing_key_value",
    "body": [
        "class HashNode {",
        "public:",
        "    pair<pair<string, int>, string> data;",
        "",
        "    HashNode(string key, string value, int index) {",
        "        data.first.first = key;",
        "        data.second = value;",
        "        data.first.second = index;",
        "    }",
        "",
        "    HashNode() {",
        "        data.first.second = -1;",
        "        data.first.first = \" \";",
        "        data.second = \" \";",
        "    }",
        "};",
        "",
        "class HashTable {",
        "    HashNode** table;",
        "    int current_size;",
        "    int Table_Size;",
        "",
        "public:",
        "    HashTable() {",
        "        Table_Size = 10;",
        "        table = new HashNode*[Table_Size];",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            table[i] = nullptr;",
        "        }",
        "        current_size = 0;",
        "    }",
        "",
        "    int HashFunction1(string key) {",
        "        int k = 0;",
        "        for (int i = 0; i < key.length(); i++) {",
        "            k += key[i];",
        "        }",
        "        return k % Table_Size;",
        "    }",
        "",
        "    int HashFunction2(string key) {",
        "        int k = 0;",
        "        for (int i = 0; i < key.length(); i++) {",
        "            k += key[i];",
        "        }",
        "        return 7 - (k % 7); // 7 is a prime number",
        "    }",
        "",
        "    void insert_record(string key, string value) {",
        "        int hash1 = HashFunction1(key);",
        "        int hash2 = HashFunction2(key);",
        "",
        "        if (table[hash1] == nullptr) {",
        "            table[hash1] = new HashNode(key, value, 0);",
        "            return;",
        "        } else if (table[hash1]->data.first.first == key) {",
        "            table[hash1]->data.second = value;",
        "            return;",
        "        }",
        "",
        "        int i = 1;",
        "        while (table[(hash1 + i * hash2) % Table_Size] != nullptr) {",
        "            i++;",
        "        }",
        "        table[(hash1 + i * hash2) % Table_Size] = new HashNode(key, value, i);",
        "    }",
        "",
        "    void search(string key) {",
        "        int hash1 = HashFunction1(key);",
        "        if (table[hash1] != nullptr && table[hash1]->data.first.first == key) {",
        "            cout << \"The value of \" << key << \" is: \" << table[hash1]->data.second << endl;",
        "            return;",
        "        }",
        "",
        "        int hash2 = HashFunction2(key);",
        "        int i = 1;",
        "        while (table[(hash1 + i * hash2) % Table_Size] != nullptr &&",
        "               table[(hash1 + i * hash2) % Table_Size]->data.first.first != key) {",
        "            i++;",
        "        }",
        "",
        "        if (table[(hash1 + i * hash2) % Table_Size] != nullptr) {",
        "            cout << \"The value of \" << key << \" is: \" << table[(hash1 + i * hash2) % Table_Size]->data.second << endl;",
        "        } else {",
        "            cout << \"Key \" << key << \" not found.\" << endl;",
        "        }",
        "    }",
        "",
        "    void display() {",
        "        for (int i = 0; i < Table_Size; i++) {",
        "            cout << \"Bucket \" << i << \": \";",
        "            if (table[i] != nullptr) {",
        "                cout << \"(\" << table[i]->data.first.first << \", \" << table[i]->data.second << \") -> \";",
        "            }",
        "            cout << \"nullptr\" << endl;",
        "        }",
        "    }",
        "",
        "    void delete_record(string key) {",
        "        int hash1 = HashFunction1(key);",
        "        if (table[hash1] != nullptr && table[hash1]->data.first.first == key) {",
        "            table[hash1]->data.first.first = \" \";",
        "            table[hash1]->data.second = \" \";",
        "            return;",
        "        }",
        "",
        "        int hash2 = HashFunction2(key);",
        "        int i = 1;",
        "        while (table[(hash1 + i * hash2) % Table_Size] != nullptr &&",
        "               table[(hash1 + i * hash2) % Table_Size]->data.first.first != key) {",
        "            i++;",
        "        }",
        "",
        "        if (table[(hash1 + i * hash2) % Table_Size] != nullptr) {",
        "            table[(hash1 + i * hash2) % Table_Size]->data.first.first = \" \";",
        "            table[(hash1 + i * hash2) % Table_Size]->data.second = \" \";",
        "        } else {",
        "            cout << \"Key \" << key << \" not found.\" << endl;",
        "        }",
        "    }",
        "}"
    ],
    "description": "HashTable implementation with double hashing for key-value storage, including operations for insertion, search, deletion, and display."
},
"PriorityQueue_Heap": {
    "scope": "cpp",
    "prefix": "priority_queue_heap",
    "body": [
        "class PriorityQueue {",
        "private:",
        "    vector<int> heap; // Vector to store the elements",
        "",
        "    // Helper function to maintain the heap property",
        "    void heapifyUp(int index) {",
        "        if (index && heap[parent(index)] < heap[index]) {",
        "            swap(heap[parent(index)], heap[index]);",
        "            heapifyUp(parent(index));",
        "        }",
        "    }",
        "",
        "    // Helper function to maintain the heap property after deletion",
        "    void heapifyDown(int index) {",
        "        int leftChildIndex = leftChild(index);",
        "        int rightChildIndex = rightChild(index);",
        "        int largest = index;",
        "",
        "        if (leftChildIndex < heap.size() && heap[leftChildIndex] > heap[largest]) {",
        "            largest = leftChildIndex;",
        "        }",
        "",
        "        if (rightChildIndex < heap.size() && heap[rightChildIndex] > heap[largest]) {",
        "            largest = rightChildIndex;",
        "        }",
        "",
        "        if (largest != index) {",
        "            swap(heap[index], heap[largest]);",
        "            heapifyDown(largest);",
        "        }",
        "    }",
        "",
        "    int parent(int index) { return (index - 1) / 2; }",
        "    int leftChild(int index) { return 2 * index + 1; }",
        "    int rightChild(int index) { return 2 * index + 2; }",
        "",
        "public:",
        "    // Insert a new element",
        "    void insert(int element) {",
        "        heap.push_back(element);",
        "        heapifyUp(heap.size() - 1);",
        "    }",
        "",
        "    // Delete the maximum element (root)",
        "    int deleteMax() {",
        "        if (heap.empty()) {",
        "            throw runtime_error(\"Priority Queue is empty\");",
        "        }",
        "",
        "        int root = heap[0];",
        "        heap[0] = heap.back();",
        "        heap.pop_back();",
        "        heapifyDown(0);",
        "",
        "        return root;",
        "    }",
        "",
        "    // Search for an element",
        "    bool search(int element) {",
        "        for (int i = 0; i < heap.size(); i++) {",
        "            if (heap[i] == element) {",
        "                return true;",
        "            }",
        "        }",
        "        return false;",
        "    }",
        "",
        "    // Reverse the priority queue",
        "    void reverse() {",
        "        reverse(heap.begin(), heap.end());",
        "    }",
        "",
        "    // Print the priority queue",
        "    void print() {",
        "        for (int i : heap) {",
        "            cout << i << \" \";",
        "        }",
        "        cout << endl;",
        "    }",
        "",
        "    // Get the maximum element (root)",
        "    int peek() {",
        "        if (heap.empty()) {",
        "            throw runtime_error(\"Priority Queue is empty\");",
        "        }",
        "        return heap[0];",
        "    }",
        "};",
        "",
        "// Test the PriorityQueue class",
        "int main() {",
        "    PriorityQueue pq;",
        "",
        "    pq.insert(10);",
        "    pq.insert(20);",
        "    pq.insert(5);",
        "    pq.insert(15);",
        "    pq.insert(30);",
        "",
        "    cout << \"Priority Queue after insertion: \";",
        "    pq.print();",
        "",
        "    cout << \"Max element (root): \" << pq.peek() << endl;",
        "",
        "    cout << \"Deleted max element: \" << pq.deleteMax() << endl;",
        "    pq.print();",
        "",
        "    cout << \"Searching for 15 in the queue: \" << (pq.search(15) ? \"Found\" : \"Not found\") << endl;",
        "",
        "    pq.reverse();",
        "    cout << \"Priority Queue after reversing: \";",
        "    pq.print();",
        "",
        "    return 0;",
        "}"
    ],
    "description": "PriorityQueue class implementing a max-heap with insert, deleteMax, search, reverse, print, and peek operations."
},

}